# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Multivariate normal density.
#'
#' Evaluate the multivariate normal density.
#'
#' @param x A numeric matrix whose rows represent the points at which to
#' evaluate the density.
#' @param mean A numeric vector containing the univariate means.
#' @param sigma A positive definite numeric matrix representing the covariance
#' matrix of the distribution.
#' @param logd Boolean length-one vector; if TRUE the log density is returned.
#'
#' @return A numeric vector.
#' @export
#'
#' @references
#' \url{http://gallery.rcpp.org/articles/dmvnorm_arma/}
#' 
#' @examples
#' set.seed(123)
#' ### Covariance matrix and mean vector
#' sigma <- bayesm::rwishart(10, diag(8))$IW
#' mean <- rnorm(8)
#' ### Benchmarking
#' n <- 1e+4
#' X <- mvtnorm::rmvnorm(n, mean, sigma)
#' require(rbenchmark)
#' benchmark(mvtnorm::dmvnorm(X, mean, sigma, log = FALSE), 
#'           dmvn_arma(X, mean, sigma, FALSE),
#'           order = "relative", replications = 100)[, 1:4]
dmvn_arma <- function(x, mean, sigma, logd = FALSE) {
    .Call('_netcopula_dmvn_arma', PACKAGE = 'netcopula', x, mean, sigma, logd)
}

#' Multivariate normal variates generation.
#'
#' Generation of multivariate normal variates.
#'
#' @param n A length-one numeric vector providing the number of draws to
#' generate.
#' @param mean A numeric vector containing the univariate means.
#' @param sigma A positive definite numeric matrix representing the covariance
#' matrix of the distribution.
#'
#' @return A numeric matrix.
#' @export
#'
#' @references
#' \url{http://gallery.rcpp.org/articles/simulate-multivariate-normal/}
#' 
#' @examples
#' set.seed(123)
#' ### Covariance matrix and mean vector
#' sigma <- matrix(c(1, 0.9, -0.3, 0.9, 1, -0.4, -0.3, -0.4, 1), ncol = 3)
#' mu <- c(10, 5, -3)
#' ### Benchmarking
#' n <- 1e+4
#' require(rbenchmark)
#' benchmark(mvtnorm::rmvnorm(n, mu, sigma),
#'           MASS::mvrnorm(n, mu, sigma),
#'           rmvn_arma(n, mu, sigma),
#'           columns = c("test", "replications", "relative", "elapsed"),
#'           order = "relative")
rmvn_arma <- function(n, mean, sigma) {
    .Call('_netcopula_rmvn_arma', PACKAGE = 'netcopula', n, mean, sigma)
}

#' Inverse Wishart density.
#'
#' Evaluation of the inverse Wishart density.
#'
#' @param IW A numeric matrix at which to evaluate the density.
#' @param nu Integer length-one vector providing the number of degrees of
#' freedom.
#' @param S Symmetric, positive definite numeric matrix representing the
#' distribution scale matrix.
#' @param logd Boolean length-one vector; if TRUE the log density is returned.
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' set.seed(123)
#' ### Parameters
#' k <- 8
#' S <- bayesm::rwishart(10, diag(k))$IW
#' nu <- round(runif(1, min = (k + 1), max = 30))
#' ### Benchmarking
#' n <- 1e+2
#' X <- array(NA, dim = c(n, k, k))
#' for (i in 1:n) X[i, , ] <- MCMCpack::riwish(nu, S)
#' require(rbenchmark)
#' benchmark(apply(X, 1, MCMCpack::diwish, nu, S),
#'           apply(X, 1, dinvwish_arma, nu, S, FALSE),
#'           order = "relative", replications = 100)[, 1:4]
dinvwish_arma <- function(IW, nu, S, logd = FALSE) {
    .Call('_netcopula_dinvwish_arma', PACKAGE = 'netcopula', IW, nu, S, logd)
}

#' Inverse Wishart variates generation.
#'
#' Generate a single inverse Wishart variate.
#'
#' @param nu Integer length-one vector providing the number of degrees of
#' freedom.
#' @param S Symmetric, positive definite numeric matrix representing the
#' distribution scale matrix.
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @references
#' \url{https://en.wikipedia.org/wiki/
#' Wishart_distribution#Bartlett_decomposition}
#'
#' @examples
#' set.seed(123)
#' ### Parameters
#' k <- 8
#' S <- bayesm::rwishart(10, diag(k))$IW
#' nu <- round(runif(1, min = (k + 1), max = 30))
#' ### Benchmarking
#' n <- 1e+2
#' require(rbenchmark)
#' benchmark(apply(rWishart(n, nu, S), 3, solve),
#'           replicate(n, MCMCpack::riwish(nu, S), simplify = "array"),
#'           replicate(n, rinvwish_arma(nu, S), simplify = "array"),
#'           columns = c("test", "replications", "relative", "elapsed"),
#'           order = "relative")
rinvwish_arma <- function(nu, S) {
    .Call('_netcopula_rinvwish_arma', PACKAGE = 'netcopula', nu, S)
}

#' Compute the density function of a Lewandowski-Kurowicka-Joe distribution.
#'
#' Compute the density function of a Lewandowski-Kurowicka-Joe distribution
#' for a correlation matrix.
#'
#' @param R A numeric matrix that representing the correlation matrix.
#' @param eta Length-one numeric vector representing the parameter of the
#' distribution.
#' @param logd Boolean length-one vector; if TRUE the log density is returned.
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @references
#' Lewandowski, D., Kurowicka, D., and Joe, H. (2009). Generating random
#' correlation matrices based on vines and extended onion method. Journal of
#' Multivariate Analysis, 100:1989-2001.
#' 
#' @details
#' This function is a port of the corresponding Stan (\url{http://mc-stan.
#' org}) function developed using the Eigen library (\url{http://eigen.
#' tuxfamily.org}).
#' 
#' @examples
#' set.seed(123)
#' K <- 5
#' R <- rlkj_arma(K, .5) # eta = 0.5
#' dlkj_arma(R, .5)
#' R <- rlkj_arma(K, 1) # eta = 1
#' dlkj_arma(R, 1)
#' R <- rlkj_arma(K, 2) # eta = 2
#' dlkj_arma(R, 2)
dlkj_arma <- function(R, eta, logd = FALSE) {
    .Call('_netcopula_dlkj_arma', PACKAGE = 'netcopula', R, eta, logd)
}

#' Generate random variate from a Lewandowski-Kurowicka-Joe distribution.
#'
#' Generation of a single draw from a Lewandowski-Kurowicka-Joe distribution
#' for a correlation matrix.
#'
#' @param K Length-one numeric vector that represents the size of the matrix.
#' @param eta Length-one numeric vector representing the parameter of the
#' distribution.
#'
#' @return A numeric (correlation) matrix.
#' @export
#'
#' @references
#' Lewandowski, D., Kurowicka, D., and Joe, H. (2009). Generating random
#' correlation matrices based on vines and extended onion method. Journal of
#' Multivariate Analysis, 100:1989-2001.
#' 
#' @details
#' This function is a port of the corresponding Stan (\url{http://mc-stan.
#' org}) function developed using the Eigen library (\url{http://eigen.
#' tuxfamily.org}).
#' 
#' @examples
#' set.seed(123)
#' K <- 5
#' rlkj_arma(K, .5) # eta = 0.5
#' rlkj_arma(K, 1) # eta = 1
#' rlkj_arma(K, 2) # eta = 2
rlkj_arma <- function(K, eta) {
    .Call('_netcopula_rlkj_arma', PACKAGE = 'netcopula', K, eta)
}

#' The truncated univariate normal distribution.
#'
#' Generation of draws from a truncated normal distribution with mean equal
#' to \code{mean} and standard deviation equal to \code{sd}.
#'
#' @param n Length-one numeric vector representing the number of draws.
#' @param a A numeric vector providing the lower bounds. These may be
#' \code{-Inf}.
#' @param b A numeric vector providing the upper bounds. These may be
#' \code{Inf}.
#' @param mean A numeric vector of means.
#' @param sd A numeric vector of standard deviations.
#'
#' @return A numeric vector.
#' @export
#'
#' @references
#' Geweke, J. (1991). Efficient simulation from the multivariate normal and
#' student-t distributions subject to linear constraints. In Computing Science
#' and Statistics: Proceedings of the 23rd Symposium on the Interface, ed. E.
#' Keramidas and S. Kaufman, pp. 571-8. Fairfax Station, VA: Interface
#' Foundation of North America.
#' 
#' @details
#' The values of \code{a}, \code{b}, \code{mean} and \code{sd} are recycled as
#' needed.
#'
#' This function is a Rcpp port of the corresponding 
#' \code{\link[truncnorm]{rtruncnorm}} function from the \code{truncnorm}
#' package.
#' 
#' @examples
#' n <- 20
#' a <- 0
#' b <- Inf
#' mean <- 0
#' sd <- 1
#' rng <- round(runif(1, 1, 10000))
#' set.seed(rng)
#' rtruncnorm_rcpp(n, a, b, mean, sd)
rtruncnorm_rcpp <- function(n, a, b, mean, sd) {
    .Call('_netcopula_rtruncnorm_rcpp', PACKAGE = 'netcopula', n, a, b, mean, sd)
}

#' The truncated univariate normal distribution.
#'
#' Density of a truncated normal distribution with mean equal to \code{mean}
#' and standard deviation equal to \code{sd}.
#'
#' @param x A numeric vector containing the values at which to evaluate the
#' density.
#' @param a A numeric vector providing the lower bounds. These may be
#' \code{-Inf}.
#' @param b A numeric vector providing the upper bounds. These may be
#' \code{Inf}.
#' @param mean A numeric vector of means.
#' @param sd A numeric vector of standard deviations.
#'
#' @return A numeric vector.
#' @export
#'
#' @details
#' The values of \code{a}, \code{b}, \code{mean} and \code{sd} are recycled as
#' needed.
#'
#' This function is a Rcpp port of the corresponding 
#' \code{\link[truncnorm]{dtruncnorm}} function from the \code{truncnorm}
#' package.
#' 
#' @examples
#' a <- 0
#' b <- Inf
#' mean <- 0
#' sd <- 1
#' rng <- round(runif(1, 1, 10000))
#' set.seed(rng)
#' n <- 20
#' x <- rtruncnorm_rcpp(n, a, b, mean, sd)
#' dtruncnorm_rcpp(x, a, b, mean, sd)
dtruncnorm_rcpp <- function(x, a, b, mean, sd) {
    .Call('_netcopula_dtruncnorm_rcpp', PACKAGE = 'netcopula', x, a, b, mean, sd)
}

#' Log Cholesky prior distribution.
#'
#' Evaluation of the prior distribution based on the log Cholesky
#' factorization for a covariance matrix \eqn{\Sigma_M} .
#'
#' @param A A numeric matrix at which to evaluate the prior density.
#' @param sigma_r Length-one numeric vector providing the standard deviation
#' of the underlying normal distributions used to generate the Cholesky
#' factors.
#' @param logd Boolean length-one vector; if TRUE the log density is returned.
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' M <- 5
#' sigma_r <- 10^-(1/3)
#' rng <- round(runif(1, 1, 10000))
#' set.seed(rng)
#' Sigma <- rlogchol_arma(M, sigma_r)
#' dlogchol_arma(Sigma, sigma_r)
dlogchol_arma <- function(A, sigma_r, logd = FALSE) {
    .Call('_netcopula_dlogchol_arma', PACKAGE = 'netcopula', A, sigma_r, logd)
}

#' Log Cholesky prior distribution.
#'
#' Generation of a single draw from the prior distribution of the
#' \eqn{\Sigma_M} matrix based on the log Cholesky factorization.
#'
#' @param M Length-one numeric vector representing the covariance matrix size.
#' @param sigma_r Length-one numeric vector providing the standard deviation
#' of the underlying normal distributions used to generate the Cholesky
#' factors.
#'
#' @return A numeric matrix.
#' @export
#'
#' @examples
#' M <- 5
#' sigma_r <- 10^-(1/3)
#' rng <- round(runif(1, 1, 10000))
#' set.seed(rng)
#' Sigma <- rlogchol_arma(M, sigma_r)
#' all(eigen(Sigma)$values > 0)
#' Sigma_sqrt <- solve(diag(diag(Sigma)))^0.5
#' Sigma_sqrt %*% Sigma %*% Sigma_sqrt
rlogchol_arma <- function(M, sigma_r) {
    .Call('_netcopula_rlogchol_arma', PACKAGE = 'netcopula', M, sigma_r)
}

#' Multivariate t density.
#'
#' Evaluate the multivariate t density.
#'
#' @param x A numeric matrix whose rows represent the points at which to
#' evaluate the density.
#' @param mean A numeric vector containing the univariate means.
#' @param sigma A positive definite numeric matrix representing the covariance
#' matrix of the distribution.
#' @param df Integer length-one vector providing the number of degrees of
#' freedom.
#' @param logd Boolean length-one vector; if TRUE the log density is returned.
#'
#' @return A numeric vector.
#' @export
#'
#' @references
#' \url{http://gallery.rcpp.org/articles/dmvnorm_arma/}
#' 
#' @examples
#' set.seed(123)
#' ### Covariance matrix and mean vector
#' sigma <- bayesm::rwishart(10, diag(8))$IW
#' mean <- rnorm(8)
#' ### Benchmarking
#' n <- 1e+4
#' df <- 20
#' X <- mvtnorm::rmvt(n, sigma, df, mean)
#' require(rbenchmark)
#' benchmark(mvtnorm::dmvt(X, mean, sigma, df, log = FALSE), 
#'           LearnBayes::dmt(X, mean, sigma, df, FALSE),
#'           dmvt_arma(X, mean, sigma, df, FALSE),
#'           order = "relative", replications = 100)[, 1:4]
dmvt_arma <- function(x, mean, sigma, df, logd = FALSE) {
    .Call('_netcopula_dmvt_arma', PACKAGE = 'netcopula', x, mean, sigma, df, logd)
}

#' Multivariate t variates generation.
#'
#' Generation of multivariate t variates.
#'
#' @param n A length-one numeric vector providing the number of draws to
#' generate.
#' @param mean A numeric vector containing the univariate means.
#' @param sigma A positive definite numeric matrix representing the covariance
#' matrix of the distribution.
#' @param df Integer length-one vector providing the number of degrees of
#' freedom.
#'
#' @return A numeric matrix.
#' @export
#'
#' @references
#' \url{http://gallery.rcpp.org/articles/simulate-multivariate-normal/}
#' 
#' @examples
#' set.seed(123)
#' ### Covariance matrix and mean vector
#' sigma <- matrix(c(1, 0.9, -0.3, 0.9, 1, -0.4, -0.3, -0.4, 1), ncol = 3)
#' mu <- c(10, 5, -3)
#' df <- 7
#' ### Benchmarking
#' n <- 1e+4
#' require(rbenchmark)
#' benchmark(mvtnorm::rmvt(n, sigma, df, mu),
#'           LearnBayes::rmt(n, mu, sigma, df),
#'           rmvt_arma(n, mu, sigma, df),
#'           columns = c("test", "replications", "relative", "elapsed"),
#'           order = "relative")
rmvt_arma <- function(n, mean, sigma, df) {
    .Call('_netcopula_rmvt_arma', PACKAGE = 'netcopula', n, mean, sigma, df)
}

#' Inverse gamma density.
#'
#' Evaluate the inverse gamma density.
#'
#' @param x A numeric vector whose representing the points at which to evaluate
#' the density.
#' @param alpha Inverse gamma shape parameter. Must be strictly positive.
#' @param beta Inverse gamma scale parameter. Must be strictly positive.
#' @param logd Boolean length-one vector; if TRUE the log density is returned.
#'
#' @return A numeric vector.
#' @export
#'
#' @examples
#' x <- seq(.01, 50, length.out = 1000)
#' alpha <- 1
#' beta <- 5
#' res <- dinvgamma_rcpp(x, alpha, beta)
#' plot(x, res, type = "l", main = "Inverse Gamma density")
dinvgamma_rcpp <- function(x, alpha, beta, logd = FALSE) {
    .Call('_netcopula_dinvgamma_rcpp', PACKAGE = 'netcopula', x, alpha, beta, logd)
}

#' Inverse gamma variates generation.
#'
#' Generation of inverse gamma variates.
#'
#' @param n A length-one numeric vector providing the number of draws to
#' generate.
#' @param alpha Inverse gamma shape parameter. Must be strictly positive.
#' @param beta Inverse gamma scale parameter. Must be strictly positive.
#'
#' @return A numeric vector.
#' @export
#'
#' @examples
#' set.seed(123)
#' n <- 1e4
#' alpha <- 3
#' beta <- 5
#' x <- sort(rinvgamma_rcpp(n, alpha, beta))
#' hist(x, breaks = 30, xlab = "x", freq = FALSE,
#'      main = "Inverse gamma variates")
#' lines(x, dinvgamma_rcpp(x, alpha, beta))
rinvgamma_rcpp <- function(n, alpha, beta) {
    .Call('_netcopula_rinvgamma_rcpp', PACKAGE = 'netcopula', n, alpha, beta)
}

#' Gaussian copula density evaluation.
#'
#' Evaluates a Gaussian copula density.
#'
#' @param u A numeric vector providing the point at which to evaluate the
#' copula density.
#' @param Gamma A numeric matrix providing the Gaussian copula correlation
#' matrix. These elements need to be provided row-wise (i.e., g_12, g_13,
#' \ldots, g_1M, g_23, g_24,\ldots, g_2M,\ldots,g_(M-1)(M-1)).
#' @param is_u A length-one logical vector indicating whether the \code{u}
#' argument provides the \eqn{u} or the \eqn{\Phi^{-1}(u)} values.
#' @param logd Boolean length-one vector; if TRUE the log density is returned.
#'
#' @return A length-one numeric vector.
#' @export
gausscopdens <- function(u, Gamma, is_u = FALSE, logd = FALSE) {
    .Call('_netcopula_gausscopdens', PACKAGE = 'netcopula', u, Gamma, is_u, logd)
}

#' Transform an Armadillo field<vec> to a matrix
#'
#' Unlists vectors in a field and places them into a matrix
#' @param x A \code{field<vec>}.
#' @return A \code{mat} containing the field elements within a column.
#' @author https://github.com/coatless/r-to-armadillo
field_to_matrix <- function(x) {
    .Call('_netcopula_field_to_matrix', PACKAGE = 'netcopula', x)
}

#' Internal functions for MCMC simulation.
#'
#' For internal use only.
#'
#' @param data internal data structure
#' @param init internal data structure
#' @param totiter internal data structure
#' @param prior internal data structure
#' @param prop internal data structure
#' @param tuning internal data structure
#' @param adapt internal data structure
#' @param verbose internal data structure
#'
#' @aliases netcopula-internal
#' @aliases netcopula_internal
#'
nc_mcmc_mh <- function(data, init, totiter, prior, prop, tuning, adapt, verbose) {
    .Call('_netcopula_nc_mcmc_mh', PACKAGE = 'netcopula', data, init, totiter, prior, prop, tuning, adapt, verbose)
}

#' Internal functions.
#'
#' For internal use only.
#'
#' @param Sigma_M internal data structure
#' @param n internal data structure
#'
#' @aliases Sigma_block
#'
Sigma_block <- function(Sigma_M, n) {
    .Call('_netcopula_Sigma_block', PACKAGE = 'netcopula', Sigma_M, n)
}

#' Internal functions.
#'
#' For internal use only.
#'
#' @param p internal data structure
#'
#' @aliases logit_rcpp
#'
logit_rcpp <- function(p) {
    .Call('_netcopula_logit_rcpp', PACKAGE = 'netcopula', p)
}

#' Internal functions.
#'
#' For internal use only.
#'
#' @param x internal data structure
#'
#' @aliases expit_rcpp
#'
expit_rcpp <- function(x) {
    .Call('_netcopula_expit_rcpp', PACKAGE = 'netcopula', x)
}

#' Internal functions.
#'
#' For internal use only.
#'
#' @param prm_wide internal data structure
#' @param narms internal data structure
#' @param rowindex internal data structure
#'
#' @aliases param_long
#'
param_long <- function(prm_wide, narms, rowindex) {
    .Call('_netcopula_param_long', PACKAGE = 'netcopula', prm_wide, narms, rowindex)
}

#' Internal functions.
#'
#' For internal use only.
#'
#' @param prm_long internal data structure
#' @param narms internal data structure
#' @param trt internal data structure
#' @param baseline internal data structure
#'
#' @aliases param_wide
#'
param_wide <- function(prm_long, narms, trt, baseline) {
    .Call('_netcopula_param_wide', PACKAGE = 'netcopula', prm_long, narms, trt, baseline)
}

#' Internal functions.
#'
#' For internal use only.
#'
#' @param Gamma_chain internal data structure
#' @param n internal data structure
#' @param M internal data structure
#'
#' @aliases spearman_mcmc
#'
spearman_mcmc <- function(Gamma_chain, n, M) {
    .Call('_netcopula_spearman_mcmc', PACKAGE = 'netcopula', Gamma_chain, n, M)
}

