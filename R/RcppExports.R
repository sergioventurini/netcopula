# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @export
qnorm_boost <- function(p, mean = 0.0, sd = 1.0, lower_tail = TRUE) {
    .Call('netcopula_qnorm_boost', PACKAGE = 'netcopula', p, mean, sd, lower_tail)
}

#' @export
pnorm_boost <- function(x, mean = 0.0, sd = 1.0, lower_tail = TRUE) {
    .Call('netcopula_pnorm_boost', PACKAGE = 'netcopula', x, mean, sd, lower_tail)
}

#' @export
qbinom_boost <- function(p, n, prob, lower_tail = TRUE) {
    .Call('netcopula_qbinom_boost', PACKAGE = 'netcopula', p, n, prob, lower_tail)
}

#' @export
pbinom_boost <- function(x, n, prob, lower_tail = TRUE) {
    .Call('netcopula_pbinom_boost', PACKAGE = 'netcopula', x, n, prob, lower_tail)
}

#' Multivariate normal density.
#'
#' Evaluate the multivariate normal density.
#'
#' @param x Numeric matrix whose rows represent the points at which to
#' evaluate the density.
#' @param mean Numeric vector containing the univariate means.
#' @param sigma Numeric positive definite matrix representing the covariance
#' matrix of the distribution.
#' @param logd Boolean length-one vector; if TRUE the log density is returned.
#'
#' @return A numeric vector.
#' @export
#'
#' @references
#' \url{http://gallery.rcpp.org/articles/dmvnorm_arma/}
#' 
#' @examples
#' set.seed(123)
#' ### Covariance matrix and mean vector
#' sigma <- bayesm::rwishart(10, diag(8))$IW
#' mean <- rnorm(8)
#' ### Benchmarking
#' n <- 1e+4
#' X <- mvtnorm::rmvnorm(n, mean, sigma)
#' require(rbenchmark)
#' benchmark(mvtnorm::dmvnorm(X, mean, sigma, log = FALSE), 
#'           dmvn_arma(X, mean, sigma, FALSE),
#'           order = "relative", replications = 100)[, 1:4]
dmvn_arma <- function(x, mean, sigma, logd = FALSE) {
    .Call('netcopula_dmvn_arma', PACKAGE = 'netcopula', x, mean, sigma, logd)
}

#' Multivariate normal variates generation.
#'
#' Generate of multivariate normal variates.
#'
#' @param n Numeric length-one vector providing the number of draws to
#' generate.
#' @param mean Numeric vector containing the univariate means.
#' @param sigma Numeric positive definite matrix representing the covariance
#' matrix of the distribution.
#'
#' @return A numeric matrix.
#' @export
#'
#' @references
#' \url{http://gallery.rcpp.org/articles/simulate-multivariate-normal/}
#' 
#' @examples
#' set.seed(123)
#' ### Covariance matrix and mean vector
#' sigma <- matrix(c(1, 0.9, -0.3, 0.9, 1, -0.4, -0.3, -0.4, 1), ncol = 3)
#' mu <- c(10, 5, -3)
#' ### Benchmarking
#' n <- 1e+4
#' require(rbenchmark)
#' benchmark(mvtnorm::rmvnorm(n, mu, sigma),
#'           MASS::mvrnorm(n, mu, sigma),
#'           rmvn_arma(n, mu, sigma),
#'           columns = c("test", "replications", "relative", "elapsed"),
#'           order = "relative")
rmvn_arma <- function(n, mean, sigma) {
    .Call('netcopula_rmvn_arma', PACKAGE = 'netcopula', n, mean, sigma)
}

#' Inverse Wishart density.
#'
#' Evaluation of the inverse Wishart density.
#'
#' @param IW Numeric matrix at which to evaluate the density.
#' @param nu Integer length-one vector providing the number of degrees of
#' freedom.
#' @param S Symmetric, positive definite numeric matrix representing the
#' distribution scale matrix.
#' @param logd Boolean length-one vector; if TRUE the log density is returned.
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' set.seed(123)
#' ### Parameters
#' k <- 8
#' S <- bayesm::rwishart(10, diag(k))$IW
#' nu <- round(runif(1, min = (k + 1), max = 30))
#' ### Benchmarking
#' n <- 1e+2
#' X <- array(NA, dim = c(n, k, k))
#' for (i in 1:n) X[i, , ] <- MCMCpack::riwish(nu, S)
#' require(rbenchmark)
#' benchmark(apply(X, 1, MCMCpack::diwish, nu, S),
#'           apply(X, 1, dinvwish_arma, nu, S, FALSE),
#'           order = "relative", replications = 100)[, 1:4]
dinvwish_arma <- function(IW, nu, S, logd = FALSE) {
    .Call('netcopula_dinvwish_arma', PACKAGE = 'netcopula', IW, nu, S, logd)
}

#' Inverse Wishart variates generation.
#'
#' Generate a single inverse Wishart variate.
#'
#' @param nu Integer length-one vector providing the number of degrees of
#' freedom.
#' @param S Symmetric, positive definite numeric matrix representing the
#' distribution scale matrix.
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @references
#' \url{https://en.wikipedia.org/wiki/
#' Wishart_distribution#Bartlett_decomposition}
#'
#' @examples
#' set.seed(123)
#' ### Parameters
#' k <- 8
#' S <- bayesm::rwishart(10, diag(k))$IW
#' nu <- round(runif(1, min = (k + 1), max = 30))
#' ### Benchmarking
#' n <- 1e+2
#' require(rbenchmark)
#' benchmark(apply(rWishart(n, nu, S), 3, solve),
#'           replicate(n, MCMCpack::riwish(nu, S), simplify = "array"),
#'           replicate(n, rinvwish_arma(nu, S), simplify = "array"),
#'           columns = c("test", "replications", "relative", "elapsed"),
#'           order = "relative")
rinvwish_arma <- function(nu, S) {
    .Call('netcopula_rinvwish_arma', PACKAGE = 'netcopula', nu, S)
}

#' Compute the density function of a Lewandowski-Kurowicka-Joe distribution.
#'
#' Compute the density function of a Lewandowski-Kurowicka-Joe distribution
#' for a correlation matrix.
#'
#' @param R Numeric matrix that representing the correlation matrix.
#' @param eta Length-one numeric vector representing the parameter of the
#' distribution.
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @references
#' Lewandowski, D., Kurowicka, D., and Joe, H. (2009). Generating random
#' correlation matrices based on vines and extended onion method. Journal of
#' Multivariate Analysis, 100:1989-2001.
#' 
#' @details
#' This function is a port of the corresponding Stan (\url{http://mc-stan.
#' org}) function developed using the Eigen library (\url{http://eigen.
#' tuxfamily.org}).
#' 
#' @examples
#' set.seed(123)
#' K <- 5
#' R <- rlkj_arma(K, .5) # eta = 0.5
#' dlkj_arma(R, .5)
#' R <- rlkj_arma(K, 1) # eta = 1
#' dlkj_arma(R, 1)
#' R <- rlkj_arma(K, 2) # eta = 2
#' dlkj_arma(R, 2)
dlkj_arma <- function(R, eta, logd = FALSE) {
    .Call('netcopula_dlkj_arma', PACKAGE = 'netcopula', R, eta, logd)
}

#' Generate random variate from a Lewandowski-Kurowicka-Joe distribution.
#'
#' Generation of a single draw from a Lewandowski-Kurowicka-Joe distribution
#' for a correlation matrix.
#'
#' @param K Length-one numeric vector that represents the size of the matrix.
#' @param eta Length-one numeric vector representing the parameter of the
#' distribution.
#'
#' @return A numeric (correlation) matrix.
#' @export
#'
#' @references
#' Lewandowski, D., Kurowicka, D., and Joe, H. (2009). Generating random
#' correlation matrices based on vines and extended onion method. Journal of
#' Multivariate Analysis, 100:1989-2001.
#' 
#' @details
#' This function is a port of the corresponding Stan (\url{http://mc-stan.
#' org}) function developed using the Eigen library (\url{http://eigen.
#' tuxfamily.org}).
#' 
#' @examples
#' set.seed(123)
#' K <- 5
#' rlkj_arma(K, .5) # eta = 0.5
#' rlkj_arma(K, 1) # eta = 1
#' rlkj_arma(K, 2) # eta = 2
rlkj_arma <- function(K, eta) {
    .Call('netcopula_rlkj_arma', PACKAGE = 'netcopula', K, eta)
}

#' The truncated univariate normal distribution.
#'
#' Generation of draws from a truncated normal distribution with mean equal
#' to \code{mean} and standard deviation equal to \code{sd}.
#'
#' @param n Length-one numeric vector representing the number of draws.
#' @param a Numeric vector providing the lower bounds. These may be
#' \code{-Inf}.
#' @param b Numeric vector providing the upper bounds. These may be
#' \code{Inf}.
#' @param mean Numeric vector of means.
#' @param sd Numeric vector of standard deviations.
#'
#' @return A numeric vector.
#' @export
#'
#' @references
#' Geweke, J. (1991). Efficient simulation from the multivariate normal and
#' student-t distributions subject to linear constraints. In Computing Science
#' and Statistics: Proceedings of the 23rd Symposium on the Interface, ed. E.
#' Keramidas and S. Kaufman, pp. 571-8. Fairfax Station, VA: Interface
#' Foundation of North America.
#' 
#' @details
#' The values of \code{a}, \code{b}, \code{mean} and \code{sd} are recycled as
#' needed.
#'
#' This function is a Rcpp port of the corresponding 
#' \code{\link[truncnorm]{rtruncnorm}} function from the \code{truncnorm}
#' package.
#' 
#' @examples
#' n <- 20
#' a <- 0
#' b <- Inf
#' mean <- 0
#' sd <- 1
#' rng <- round(runif(1, 1, 10000))
#' set.seed(rng)
#' rtruncnorm_rcpp(n, a, b, mean, sd)
rtruncnorm_rcpp <- function(n, a, b, mean, sd) {
    .Call('netcopula_rtruncnorm_rcpp', PACKAGE = 'netcopula', n, a, b, mean, sd)
}

#' The truncated univariate normal distribution.
#'
#' Generation of draws from a truncated normal distribution with mean equal
#' to \code{mean} and standard deviation equal to \code{sd}.
#'
#' @param n Length-one numeric vector representing the number of draws.
#' @param a Numeric vector providing the lower bounds. These may be
#' \code{-Inf}.
#' @param b Numeric vector providing the upper bounds. These may be
#' \code{Inf}.
#' @param mean Numeric vector of means.
#' @param sd Numeric vector of standard deviations.
#'
#' @return A numeric vector.
#' @export
#'
#' @references
#' Robert, C. (1995). Simulation of Truncated Normal Variables. Statistics
#' and Computing, 5, 121â€“125.
#' 
#' @details
#' The values of \code{a}, \code{b}, \code{mean} and \code{sd} are recycled as
#' needed.
#'
#' This function is a Rcpp port of the corresponding 
#' \code{\link[bayesm]{rtrun}} function from the \code{bayesm}
#' package.
#' 
#' @examples
#' n <- 20
#' a <- 0
#' b <- Inf
#' mean <- 0
#' sd <- 1
#' rng <- round(runif(1, 1, 10000))
#' set.seed(rng)
#' rtruncnorm2_rcpp(n, a, b, mean, sd)
rtruncnorm2_rcpp <- function(n, a, b, mean, sd) {
    .Call('netcopula_rtruncnorm2_rcpp', PACKAGE = 'netcopula', n, a, b, mean, sd)
}

#' The truncated univariate normal distribution.
#'
#' Density of a truncated normal distribution with mean equal to \code{mean}
#' and standard deviation equal to \code{sd}.
#'
#' @param x Numeric vector containing the values at which to evaluate the
#' density.
#' @param a Numeric vector providing the lower bounds. These may be
#' \code{-Inf}.
#' @param b Numeric vector providing the upper bounds. These may be
#' \code{Inf}.
#' @param mean Numeric vector of means.
#' @param sd Numeric vector of standard deviations.
#'
#' @return A numeric vector.
#' @export
#'
#' @details
#' The values of \code{a}, \code{b}, \code{mean} and \code{sd} are recycled as
#' needed.
#'
#' This function is a Rcpp port of the corresponding 
#' \code{\link[truncnorm]{dtruncnorm}} function from the \code{truncnorm}
#' package.
#' 
#' @examples
#' a <- 0
#' b <- Inf
#' mean <- 0
#' sd <- 1
#' rng <- round(runif(1, 1, 10000))
#' set.seed(rng)
#' n <- 20
#' x <- rtruncnorm_rcpp(n, a, b, mean, sd)
#' dtruncnorm_rcpp(x, a, b, mean, sd)
dtruncnorm_rcpp <- function(x, a, b, mean, sd) {
    .Call('netcopula_dtruncnorm_rcpp', PACKAGE = 'netcopula', x, a, b, mean, sd)
}

#' Log Cholesky prior distribution.
#'
#' Evaluation of the prior distribution based on the log Cholesky
#' factorization for a covariance matrix \eqn{\Sigma_M} .
#'
#' @param A Numeric matrix at which to evaluate the prior density.
#' @param sigma_r Length-one numeric vector providing the standard deviation
#' of the underlying normal distributions used to generate the Cholesky
#' factors.
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' M <- 5
#' sigma_r <- 10^-(1/3)
#' rng <- round(runif(1, 1, 10000))
#' set.seed(rng)
#' Sigma <- rlogchol_arma(M, sigma_r)
#' dlogchol_arma(Sigma, sigma_r)
dlogchol_arma <- function(A, sigma_r, logd = FALSE) {
    .Call('netcopula_dlogchol_arma', PACKAGE = 'netcopula', A, sigma_r, logd)
}

#' Log Cholesky prior distribution.
#'
#' Generation of a single draw from the prior distribution of the
#' \eqn{\Sigma_M} matrix based on the log Cholesky factorization.
#'
#' @param M Length-one numeric vector representing the covariance matrix size.
#' @param sigma_r Length-one numeric vector providing the standard deviation
#' of the underlying normal distributions used to generate the Cholesky
#' factors.
#'
#' @return A numeric matrix.
#' @export
#'
#' @examples
#' M <- 5
#' sigma_r <- 10^-(1/3)
#' rng <- round(runif(1, 1, 10000))
#' set.seed(rng)
#' Sigma <- rlogchol_arma(M, sigma_r)
#' all(eigen(Sigma)$values > 0)
#' Sigma_sqrt <- solve(diag(diag(Sigma)))^0.5
#' Sigma_sqrt %*% Sigma %*% Sigma_sqrt
rlogchol_arma <- function(M, sigma_r) {
    .Call('netcopula_rlogchol_arma', PACKAGE = 'netcopula', M, sigma_r)
}

#' Multivariate t density.
#'
#' Evaluate the multivariate t density.
#'
#' @param x Numeric matrix whose rows represent the points at which to
#' evaluate the density.
#' @param mean Numeric vector containing the univariate means.
#' @param sigma Numeric positive definite matrix representing the covariance
#' matrix of the distribution.
#' @param df Integer length-one vector providing the number of degrees of
#' freedom.
#' @param logd Boolean length-one vector; if TRUE the log density is returned.
#'
#' @return A numeric vector.
#' @export
#'
#' @references
#' \url{http://gallery.rcpp.org/articles/dmvnorm_arma/}
#' 
#' @examples
#' set.seed(123)
#' ### Covariance matrix and mean vector
#' sigma <- bayesm::rwishart(10, diag(8))$IW
#' mean <- rnorm(8)
#' ### Benchmarking
#' n <- 1e+4
#' df <- 20
#' X <- mvtnorm::rmvt(n, sigma, df, mean)
#' require(rbenchmark)
#' benchmark(mvtnorm::dmvt(X, mean, sigma, df, log = FALSE), 
#'           LearnBayes::dmt(X, mean, sigma, df, FALSE),
#'           dmvt_arma(X, mean, sigma, df, FALSE),
#'           order = "relative", replications = 100)[, 1:4]
dmvt_arma <- function(x, mean, sigma, df, logd = FALSE) {
    .Call('netcopula_dmvt_arma', PACKAGE = 'netcopula', x, mean, sigma, df, logd)
}

#' Multivariate t variates generation.
#'
#' Generate of multivariate t variates.
#'
#' @param n Numeric length-one vector providing the number of draws to
#' generate.
#' @param mean Numeric vector containing the univariate means.
#' @param sigma Numeric positive definite matrix representing the covariance
#' matrix of the distribution.
#' @param df Integer length-one vector providing the number of degrees of
#' freedom.
#'
#' @return A numeric matrix.
#' @export
#'
#' @references
#' \url{http://gallery.rcpp.org/articles/simulate-multivariate-normal/}
#' 
#' @examples
#' set.seed(123)
#' ### Covariance matrix and mean vector
#' sigma <- matrix(c(1, 0.9, -0.3, 0.9, 1, -0.4, -0.3, -0.4, 1), ncol = 3)
#' mu <- c(10, 5, -3)
#' df <- 7
#' ### Benchmarking
#' n <- 1e+4
#' require(rbenchmark)
#' benchmark(mvtnorm::rmvt(n, sigma, df, mu),
#'           LearnBayes::rmt(n, mu, sigma, df),
#'           rmvt_arma(n, mu, sigma, df),
#'           columns = c("test", "replications", "relative", "elapsed"),
#'           order = "relative")
rmvt_arma <- function(n, mean, sigma, df) {
    .Call('netcopula_rmvt_arma', PACKAGE = 'netcopula', n, mean, sigma, df)
}

#' Matrix variate normal density.
#'
#' Evaluate the matrix variate normal density.
#'
#' @param X Numeric matrix at which to evaluate the density.
#' @param M Numeric matrix containing the univariate means.
#' @param U Numeric positive definite matrix representing the covariance
#' matrix among the X rows.
#' @param V Numeric positive definite matrix representing the covariance
#' matrix among the X columns.
#' @param logd Boolean length-one vector; if TRUE the log density is returned.
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @references
#' \url{https://en.wikipedia.org/wiki/Matrix_normal_distribution}
#' 
#' @examples
#' set.seed(123)
#' n <- 10
#' p <- 3
#' x <- rnorm(n*p)
#' X <- matrix(x, nrow = n, ncol = p)
#' M <- matrix(0, nrow = n, ncol = p)
#' U <- diag(n)
#' V <- diag(p)
#' dmatvn_arma(X, M, U, V)
dmatvn_arma <- function(X, M, U, V, logd = FALSE) {
    .Call('netcopula_dmatvn_arma', PACKAGE = 'netcopula', X, M, U, V, logd)
}

#' Matrix variate normal generation.
#'
#' Generate of a single matrix normal variate.
#'
#' @param M Numeric matrix containing the univariate means.
#' @param U Numeric positive definite matrix representing the covariance
#' matrix among the X rows.
#' @param V Numeric positive definite matrix representing the covariance
#' matrix among the X columns.
#'
#' @return A numeric matrix.
#' @export
#'
#' @references
#' \url{https://en.wikipedia.org/wiki/Matrix_normal_distribution}
#' 
#' @examples
#' set.seed(123)
#' n <- 10
#' p <- 3
#' M <- matrix(0, nrow = n, ncol = p)
#' U <- diag(n)
#' V <- diag(p)
#' rmatvn_arma(M, U, V)
#' set.seed(123)
#' rmvn_arma(n, rep(0, p), diag(p))
rmatvn_arma <- function(M, U, V) {
    .Call('netcopula_rmatvn_arma', PACKAGE = 'netcopula', M, U, V)
}

#' Matrix variate t density.
#'
#' Evaluate the matrix variate t density.
#'
#' @param X Numeric matrix at which to evaluate the density.
#' @param M Numeric matrix containing the univariate means.
#' @param Omega Numeric positive definite matrix representing the covariance
#' matrix among the X rows.
#' @param Sigma Numeric positive definite matrix representing the covariance
#' matrix among the X columns.
#' @param df Integer length-one vector providing the number of degrees of
#' freedom.
#' @param logd Boolean length-one vector; if TRUE the log density is returned.
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @references
#' \url{https://en.wikipedia.org/wiki/Matrix_t_distribution}
#' 
#' @examples
#' set.seed(123)
#' n <- 10
#' p <- 3
#' x <- rnorm(n*p)
#' X <- matrix(x, nrow = n, ncol = p)
#' M <- matrix(0, nrow = n, ncol = p)
#' Sigma <- diag(n)
#' Omega <- diag(p)
#' df <- 5
#' dmatvt_arma(X, M, Sigma, Omega, df)
dmatvt_arma <- function(X, M, Sigma, Omega, df, logd = FALSE) {
    .Call('netcopula_dmatvt_arma', PACKAGE = 'netcopula', X, M, Sigma, Omega, df, logd)
}

#' Matrix variate t generation.
#'
#' Generate of a single matrix t variate.
#'
#' @param M Numeric matrix containing the univariate means.
#' @param Omega Numeric positive definite matrix representing the covariance
#' matrix among the X rows.
#' @param Sigma Numeric positive definite matrix representing the covariance
#' matrix among the X columns.
#' @param df Integer length-one vector providing the number of degrees of
#' freedom.
#'
#' @return A numeric matrix.
#' @export
#'
#' @references
#' Kollo, T., van Rosen, D. (2005). Advanced Multivariate Statistics
#' with Matrices. Springer.
#' \url{https://en.wikipedia.org/wiki/Matrix_t_distribution}
#' 
#' @examples
#' set.seed(123)
#' n <- 10
#' p <- 3
#' x <- rnorm(n*p)
#' M <- matrix(0, nrow = n, ncol = p)
#' Sigma <- diag(n)
#' Omega <- diag(p)
#' df <- 5
#' rmatvt_arma(M, Sigma, Omega, df)
rmatvt_arma <- function(M, Sigma, Omega, df) {
    .Call('netcopula_rmatvt_arma', PACKAGE = 'netcopula', M, Sigma, Omega, df)
}

#' Inverse gamma density.
#'
#' Evaluate the inverse gamma density.
#'
#' @param x Numeric vector whose representing the points at which to evaluate
#' the density.
#' @param alpha Inverse gamma shape parameter. Must be strictly positive.
#' @param beta Inverse gamma scale parameter. Must be strictly positive.
#' @param logd Boolean length-one vector; if TRUE the log density is returned.
#'
#' @return A numeric vector.
#' @export
#'
#' @examples
#' x <- seq(.01, 50, length.out = 1000)
#' alpha <- 1
#' beta <- 5
#' res <- dinvgamma_rcpp(x, alpha, beta)
#' plot(x, res, type = "l", main = "Inverse Gamma density")
dinvgamma_rcpp <- function(x, alpha, beta, logd = FALSE) {
    .Call('netcopula_dinvgamma_rcpp', PACKAGE = 'netcopula', x, alpha, beta, logd)
}

#' Inverse gamma variates generation.
#'
#' Generate of inverse gamma variates.
#'
#' @param n Numeric length-one vector providing the number of draws to
#' generate.
#' @param alpha Inverse gamma shape parameter. Must be strictly positive.
#' @param beta Inverse gamma scale parameter. Must be strictly positive.
#'
#' @return A numeric vector.
#' @export
#'
#' @examples
#' set.seed(123)
#' n <- 1e4
#' alpha <- 3
#' beta <- 5
#' x <- sort(rinvgamma_rcpp(n, alpha, beta))
#' hist(x, breaks = 30, xlab = "x", freq = FALSE,
#'      main = "Inverse gamma variates")
#' lines(x, dinvgamma_rcpp(x, alpha, beta))
rinvgamma_rcpp <- function(n, alpha, beta) {
    .Call('netcopula_rinvgamma_rcpp', PACKAGE = 'netcopula', n, alpha, beta)
}

#' Gaussian copula density evaluation.
#'
#' Evaluates a Gaussian copula density.
#'
#' @param u A numeric vector providing the point at which to evaluate the
#' copula density.
#' @param Gamma A numeric matrix providing the Gaussian copula correlation
#' matrix. These elements need to be provided row-wise (i.e., g_12, g_13,
#' \ldots, g_1M, g_23, g_24,\ldots, g_2M,\ldots,g_(M-1)(M-1)).
#' @param is_u A length-one logical vector indicating whether the \code{u}
#' argument provides the \eqn{u} or the \eqn{\Phi^{-1}(u)} values.
#' @param logd Boolean length-one vector; if TRUE the log density is returned.
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' u <- rep(0.1, 3)
#' Gamma <- c(.3, .5, .2)
#' gausscopdens(u, Gamma)
#' 
#' Gamma <- .3
#' len <- 100
#' u1 <- u2 <- seq(.01, .99, length.out = len)
#' dens <- matrix(NA, nrow = len, ncol = len)
#' for (i in 1:len) {
#'   for (j in 1:len) {
#'     dens[i, j] <- gausscopdens(c(u1[i], u2[j]), Gamma)
#'   }
#' }
#' persp(u1, u2, dens, theta = 120, phi = 25)
gausscopdens <- function(u, Gamma, is_u, logd = FALSE) {
    .Call('netcopula_gausscopdens', PACKAGE = 'netcopula', u, Gamma, is_u, logd)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param y pippo
#' @param n pippo
#' @param x pippo
#' @param trt pippo
#' @param mu pippo
#' @param delta pippo
#' @param Gamma pippo
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' # nothing for now!
nc_loglik <- function(y, n, x, trt, mu, delta, Gamma) {
    .Call('netcopula_nc_loglik', PACKAGE = 'netcopula', y, n, x, trt, mu, delta, Gamma)
}

#' @export
indic_a_b <- function(y_ikm, n_ikm, x_ikm, mu_ikm, delta_ikm) {
    .Call('netcopula_indic_a_b', PACKAGE = 'netcopula', y_ikm, n_ikm, x_ikm, mu_ikm, delta_ikm)
}

#' @export
nc_logprior <- function(mu, mu_sigma, d, d_sigma, Sigma_M, sigma_r, ref_trt) {
    .Call('netcopula_nc_logprior', PACKAGE = 'netcopula', mu, mu_sigma, d, d_sigma, Sigma_M, sigma_r, ref_trt)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param data pippo
#' @param init pippo
#' @param totiter pippo
#' @param prior pippo
#' @param prop pippo
#' @param verbose pippo
#'
#' @return A list containing the output of the MCMC simulation.
#' @export
#'
#' @examples
#' # nothing for now!
x_imputed <- function(x, Gamma, trt) {
    .Call('netcopula_x_imputed', PACKAGE = 'netcopula', x, Gamma, trt)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param data pippo
#' @param init pippo
#' @param totiter pippo
#' @param prior pippo
#' @param prop pippo
#' @param verbose pippo
#'
#' @return A list containing the output of the MCMC simulation.
#' @export
#'
#' @examples
#' # nothing for now!
n_imputed <- function(n_data) {
    .Call('netcopula_n_imputed', PACKAGE = 'netcopula', n_data)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param data pippo
#' @param init pippo
#' @param totiter pippo
#' @param prior pippo
#' @param prop pippo
#' @param verbose pippo
#'
#' @return A list containing the output of the MCMC simulation.
#' @export
#'
#' @examples
#' # nothing for now!
y_imputed <- function(y, x_imp, narms, mu, delta, n_imp) {
    .Call('netcopula_y_imputed', PACKAGE = 'netcopula', y, x_imp, narms, mu, delta, n_imp)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param nc_data pippo
#' @param x pippo
#' @param mu pippo
#' @param delta pippo
#' @param Gamma pippo
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' # nothing for now!
Gamma_logpost <- function(Gamma, x, eta) {
    .Call('netcopula_Gamma_logpost', PACKAGE = 'netcopula', Gamma, x, eta)
}

#' @export
logpost <- function(mu, delta, y, n, w, gamma, eps, eps_ab) {
    .Call('netcopula_logpost', PACKAGE = 'netcopula', mu, delta, y, n, w, gamma, eps, eps_ab)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param nc_data pippo
#' @param x pippo
#' @param mu pippo
#' @param delta pippo
#' @param Gamma pippo
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' # nothing for now!
mu_logpost <- function(mu, delta, y, n, w, gamma, mu_sigma, eps, eps_ab) {
    .Call('netcopula_mu_logpost', PACKAGE = 'netcopula', mu, delta, y, n, w, gamma, mu_sigma, eps, eps_ab)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param nc_data pippo
#' @param x pippo
#' @param mu pippo
#' @param delta pippo
#' @param Gamma pippo
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' # nothing for now!
delta_logpost <- function(delta, mu, tau, eta, y, n, w, gamma, eps, eps_ab) {
    .Call('netcopula_delta_logpost', PACKAGE = 'netcopula', delta, mu, tau, eta, y, n, w, gamma, eps, eps_ab)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param nc_data pippo
#' @param x pippo
#' @param mu pippo
#' @param delta pippo
#' @param Gamma pippo
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' # nothing for now!
delta_logprior <- function(delta, d, Sigma_M, trt_arms, baseline, narms) {
    .Call('netcopula_delta_logprior', PACKAGE = 'netcopula', delta, d, Sigma_M, trt_arms, baseline, narms)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param nc_data pippo
#' @param x pippo
#' @param mu pippo
#' @param delta pippo
#' @param Gamma pippo
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' # nothing for now!
d_logprior <- function(d, d_sigma, ref_trt) {
    .Call('netcopula_d_logprior', PACKAGE = 'netcopula', d, d_sigma, ref_trt)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param nc_data pippo
#' @param x pippo
#' @param mu pippo
#' @param delta pippo
#' @param Gamma pippo
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' # nothing for now!
d_logpost_multi <- function(d, delta, Sigma_M, trt_arms, baseline, narms, d_sigma, ref_trt) {
    .Call('netcopula_d_logpost_multi', PACKAGE = 'netcopula', d, delta, Sigma_M, trt_arms, baseline, narms, d_sigma, ref_trt)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param nc_data pippo
#' @param x pippo
#' @param mu pippo
#' @param delta pippo
#' @param Gamma pippo
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' # nothing for now!
d_logpost <- function(d, delta, Sigma_M, trt, baseline, narms_study, d_sigma, ref_trt) {
    .Call('netcopula_d_logpost', PACKAGE = 'netcopula', d, delta, Sigma_M, trt, baseline, narms_study, d_sigma, ref_trt)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param nc_data pippo
#' @param x pippo
#' @param mu pippo
#' @param delta pippo
#' @param Gamma pippo
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' # nothing for now!
Sigma_M_logpost <- function(d, delta, Sigma_M, trt, baseline, narms_study, sigma_r) {
    .Call('netcopula_Sigma_M_logpost', PACKAGE = 'netcopula', d, delta, Sigma_M, trt, baseline, narms_study, sigma_r)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param data pippo
#' @param init pippo
#' @param totiter pippo
#' @param prior pippo
#' @param prop pippo
#' @param verbose pippo
#'
#' @return A list containing the output of the MCMC simulation.
#' @export
#'
#' @examples
#' # nothing for now!
nc_mcmc_opt <- function(data, init, totiter, prior, prop, tuning, adapt, verbose) {
    .Call('netcopula_nc_mcmc_opt', PACKAGE = 'netcopula', data, init, totiter, prior, prop, tuning, adapt, verbose)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param y pippo
#' @param n pippo
#' @param x pippo
#' @param trt pippo
#' @param mu pippo
#' @param delta pippo
#' @param Gamma pippo
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' # nothing for now!
rwmh_adapt <- function(theta, mu, rho, cov, ar, alpha, beta, gamma, tar, k, iter_cols, what) {
    .Call('netcopula_rwmh_adapt', PACKAGE = 'netcopula', theta, mu, rho, cov, ar, alpha, beta, gamma, tar, k, iter_cols, what)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param data pippo
#' @param init pippo
#' @param totiter pippo
#' @param prior pippo
#' @param prop pippo
#' @param verbose pippo
#'
#' @return A list containing the output of the MCMC simulation.
#' @export
#'
#' @examples
#' # nothing for now!
nc_mcmc_mh <- function(data, init, totiter, prior, prop, tuning, adapt, verbose) {
    .Call('netcopula_nc_mcmc_mh', PACKAGE = 'netcopula', data, init, totiter, prior, prop, tuning, adapt, verbose)
}

#' @export
optim_rcpp <- function(par, fn, args, options, hessian = TRUE) {
    .Call('netcopula_optim_rcpp', PACKAGE = 'netcopula', par, fn, args, options, hessian)
}

#' @export
optimhess_rcpp <- function(par, fn, args, options) {
    .Call('netcopula_optimhess_rcpp', PACKAGE = 'netcopula', par, fn, args, options)
}

#' @export
laplace_rcpp <- function(logpost, guess, args, options) {
    .Call('netcopula_laplace_rcpp', PACKAGE = 'netcopula', logpost, guess, args, options)
}

#' @export
optim_rcpp_example <- function() {
    .Call('netcopula_optim_rcpp_example', PACKAGE = 'netcopula')
}

#' @export
optimize_rcpp <- function(fn, xmin, xmax, tol, args) {
    .Call('netcopula_optimize_rcpp', PACKAGE = 'netcopula', fn, xmin, xmax, tol, args)
}

#' @export
laplace_u_rcpp <- function(fn, xmin, xmax, tol, args, options) {
    .Call('netcopula_laplace_u_rcpp', PACKAGE = 'netcopula', fn, xmin, xmax, tol, args, options)
}

#' @export
mat_block_diag <- function(A, n) {
    .Call('netcopula_mat_block_diag', PACKAGE = 'netcopula', A, n)
}

#' @export
Sigma_block <- function(Sigma_M, n) {
    .Call('netcopula_Sigma_block', PACKAGE = 'netcopula', Sigma_M, n)
}

#' @export
df_nm <- function(x, cols) {
    .Call('netcopula_df_nm', PACKAGE = 'netcopula', x, cols)
}

#' @export
nm_stack <- function(x) {
    .Call('netcopula_nm_stack', PACKAGE = 'netcopula', x)
}

#' @export
nv_unstack <- function(x, nc) {
    .Call('netcopula_nv_unstack', PACKAGE = 'netcopula', x, nc)
}

#' @export
nv_omit <- function(x) {
    .Call('netcopula_nv_omit', PACKAGE = 'netcopula', x)
}

#' @export
nv_na_index <- function(x, dim, type) {
    .Call('netcopula_nv_na_index', PACKAGE = 'netcopula', x, dim, type)
}

#' @export
nv_miss_replace <- function(x, miss, miss_i) {
    .Call('netcopula_nv_miss_replace', PACKAGE = 'netcopula', x, miss, miss_i)
}

#' @export
split_iv <- function(x, f) {
    .Call('netcopula_split_iv', PACKAGE = 'netcopula', x, f)
}

#' @export
split_nm <- function(x, f) {
    .Call('netcopula_split_nm', PACKAGE = 'netcopula', x, f)
}

#' @export
logit_rcpp <- function(p) {
    .Call('netcopula_logit_rcpp', PACKAGE = 'netcopula', p)
}

#' @export
expit_rcpp <- function(x) {
    .Call('netcopula_expit_rcpp', PACKAGE = 'netcopula', x)
}

#' @export
nm_omit <- function(x, rownum) {
    .Call('netcopula_nm_omit', PACKAGE = 'netcopula', x, rownum)
}

#' @export
param_long <- function(prm_wide, narms, rowindex) {
    .Call('netcopula_param_long', PACKAGE = 'netcopula', prm_wide, narms, rowindex)
}

#' @export
param_wide <- function(prm_long, narms, trt, baseline) {
    .Call('netcopula_param_wide', PACKAGE = 'netcopula', prm_long, narms, trt, baseline)
}

#' @export
list_mat <- function(X) {
    .Call('netcopula_list_mat', PACKAGE = 'netcopula', X)
}

#' @export
diag_tri <- function(A) {
    .Call('netcopula_diag_tri', PACKAGE = 'netcopula', A)
}

#' @export
cube_to_mat <- function(X, is_d, ref) {
    .Call('netcopula_cube_to_mat', PACKAGE = 'netcopula', X, is_d, ref)
}

#' @export
mat_to_vec <- function(X, is_d, ref) {
    .Call('netcopula_mat_to_vec', PACKAGE = 'netcopula', X, is_d, ref)
}

#' @export
vec_to_mat <- function(x, nc, is_d, ref) {
    .Call('netcopula_vec_to_mat', PACKAGE = 'netcopula', x, nc, is_d, ref)
}

#' @export
Sigma_M_to_beta <- function(A) {
    .Call('netcopula_Sigma_M_to_beta', PACKAGE = 'netcopula', A)
}

#' @export
beta_to_Sigma_M <- function(beta, M) {
    .Call('netcopula_beta_to_Sigma_M', PACKAGE = 'netcopula', beta, M)
}

#' @export
is_symmetric <- function(A) {
    .Call('netcopula_is_symmetric', PACKAGE = 'netcopula', A)
}

#' @export
is_correlation <- function(A) {
    .Call('netcopula_is_correlation', PACKAGE = 'netcopula', A)
}

#' @export
is_positive_definite <- function(A, line) {
    .Call('netcopula_is_positive_definite', PACKAGE = 'netcopula', A, line)
}

#' @export
make_positive_definite <- function(A) {
    .Call('netcopula_make_positive_definite', PACKAGE = 'netcopula', A)
}

#' @export
is_singular <- function(A) {
    .Call('netcopula_is_singular', PACKAGE = 'netcopula', A)
}

#' @export
ols_coef <- function(xmin, xmax, args, delta_par) {
    .Call('netcopula_ols_coef', PACKAGE = 'netcopula', xmin, xmax, args, delta_par)
}

#' @export
ols_pred <- function(coef, x) {
    .Call('netcopula_ols_pred', PACKAGE = 'netcopula', coef, x)
}

#' @export
cov2cor_rcpp <- function(V) {
    .Call('netcopula_cov2cor_rcpp', PACKAGE = 'netcopula', V)
}

