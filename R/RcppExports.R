# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @export
qnorm_boost <- function(p, mean = 0.0, sd = 1.0, lower_tail = TRUE) {
    .Call('_netcopula_qnorm_boost', PACKAGE = 'netcopula', p, mean, sd, lower_tail)
}

#' @export
pnorm_boost <- function(x, mean = 0.0, sd = 1.0, lower_tail = TRUE) {
    .Call('_netcopula_pnorm_boost', PACKAGE = 'netcopula', x, mean, sd, lower_tail)
}

#' @export
qbinom_boost <- function(p, n, prob, lower_tail = TRUE) {
    .Call('_netcopula_qbinom_boost', PACKAGE = 'netcopula', p, n, prob, lower_tail)
}

#' @export
pbinom_boost <- function(x, n, prob, lower_tail = TRUE) {
    .Call('_netcopula_pbinom_boost', PACKAGE = 'netcopula', x, n, prob, lower_tail)
}

#' Multivariate normal density.
#'
#' Evaluate the multivariate normal density.
#'
#' @param x Numeric matrix whose rows represent the points at which to
#' evaluate the density.
#' @param mean Numeric vector containing the univariate means.
#' @param sigma Numeric positive definite matrix representing the covariance
#' matrix of the distribution.
#' @param logd Boolean length-one vector; if TRUE the log density is returned.
#'
#' @return A numeric vector.
#' @export
#'
#' @references
#' \url{http://gallery.rcpp.org/articles/dmvnorm_arma/}
#' 
#' @examples
#' set.seed(123)
#' ### Covariance matrix and mean vector
#' sigma <- bayesm::rwishart(10, diag(8))$IW
#' mean <- rnorm(8)
#' ### Benchmarking
#' n <- 1e+4
#' X <- mvtnorm::rmvnorm(n, mean, sigma)
#' require(rbenchmark)
#' benchmark(mvtnorm::dmvnorm(X, mean, sigma, log = FALSE), 
#'           dmvn_arma(X, mean, sigma, FALSE),
#'           order = "relative", replications = 100)[, 1:4]
dmvn_arma <- function(x, mean, sigma, logd = FALSE) {
    .Call('_netcopula_dmvn_arma', PACKAGE = 'netcopula', x, mean, sigma, logd)
}

#' Multivariate normal variates generation.
#'
#' Generate of multivariate normal variates.
#'
#' @param n Numeric length-one vector providing the number of draws to
#' generate.
#' @param mean Numeric vector containing the univariate means.
#' @param sigma Numeric positive definite matrix representing the covariance
#' matrix of the distribution.
#'
#' @return A numeric matrix.
#' @export
#'
#' @references
#' \url{http://gallery.rcpp.org/articles/simulate-multivariate-normal/}
#' 
#' @examples
#' set.seed(123)
#' ### Covariance matrix and mean vector
#' sigma <- matrix(c(1, 0.9, -0.3, 0.9, 1, -0.4, -0.3, -0.4, 1), ncol = 3)
#' mu <- c(10, 5, -3)
#' ### Benchmarking
#' n <- 1e+4
#' require(rbenchmark)
#' benchmark(mvtnorm::rmvnorm(n, mu, sigma),
#'           MASS::mvrnorm(n, mu, sigma),
#'           rmvn_arma(n, mu, sigma),
#'           columns = c("test", "replications", "relative", "elapsed"),
#'           order = "relative")
rmvn_arma <- function(n, mean, sigma) {
    .Call('_netcopula_rmvn_arma', PACKAGE = 'netcopula', n, mean, sigma)
}

#' Inverse Wishart density.
#'
#' Evaluation of the inverse Wishart density.
#'
#' @param IW Numeric matrix at which to evaluate the density.
#' @param nu Integer length-one vector providing the number of degrees of
#' freedom.
#' @param S Symmetric, positive definite numeric matrix representing the
#' distribution scale matrix.
#' @param logd Boolean length-one vector; if TRUE the log density is returned.
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' set.seed(123)
#' ### Parameters
#' k <- 8
#' S <- bayesm::rwishart(10, diag(k))$IW
#' nu <- round(runif(1, min = (k + 1), max = 30))
#' ### Benchmarking
#' n <- 1e+2
#' X <- array(NA, dim = c(n, k, k))
#' for (i in 1:n) X[i, , ] <- MCMCpack::riwish(nu, S)
#' require(rbenchmark)
#' benchmark(apply(X, 1, MCMCpack::diwish, nu, S),
#'           apply(X, 1, dinvwish_arma, nu, S, FALSE),
#'           order = "relative", replications = 100)[, 1:4]
dinvwish_arma <- function(IW, nu, S, logd = FALSE) {
    .Call('_netcopula_dinvwish_arma', PACKAGE = 'netcopula', IW, nu, S, logd)
}

#' Inverse Wishart variates generation.
#'
#' Generate a single inverse Wishart variate.
#'
#' @param nu Integer length-one vector providing the number of degrees of
#' freedom.
#' @param S Symmetric, positive definite numeric matrix representing the
#' distribution scale matrix.
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @references
#' \url{https://en.wikipedia.org/wiki/
#' Wishart_distribution#Bartlett_decomposition}
#'
#' @examples
#' set.seed(123)
#' ### Parameters
#' k <- 8
#' S <- bayesm::rwishart(10, diag(k))$IW
#' nu <- round(runif(1, min = (k + 1), max = 30))
#' ### Benchmarking
#' n <- 1e+2
#' require(rbenchmark)
#' benchmark(apply(rWishart(n, nu, S), 3, solve),
#'           replicate(n, MCMCpack::riwish(nu, S), simplify = "array"),
#'           replicate(n, rinvwish_arma(nu, S), simplify = "array"),
#'           columns = c("test", "replications", "relative", "elapsed"),
#'           order = "relative")
rinvwish_arma <- function(nu, S) {
    .Call('_netcopula_rinvwish_arma', PACKAGE = 'netcopula', nu, S)
}

#' Compute the density function of a Lewandowski-Kurowicka-Joe distribution.
#'
#' Compute the density function of a Lewandowski-Kurowicka-Joe distribution
#' for a correlation matrix.
#'
#' @param R Numeric matrix that representing the correlation matrix.
#' @param eta Length-one numeric vector representing the parameter of the
#' distribution.
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @references
#' Lewandowski, D., Kurowicka, D., and Joe, H. (2009). Generating random
#' correlation matrices based on vines and extended onion method. Journal of
#' Multivariate Analysis, 100:1989-2001.
#' 
#' @details
#' This function is a port of the corresponding Stan (\url{http://mc-stan.
#' org}) function developed using the Eigen library (\url{http://eigen.
#' tuxfamily.org}).
#' 
#' @examples
#' set.seed(123)
#' K <- 5
#' R <- rlkj_arma(K, .5) # eta = 0.5
#' dlkj_arma(R, .5)
#' R <- rlkj_arma(K, 1) # eta = 1
#' dlkj_arma(R, 1)
#' R <- rlkj_arma(K, 2) # eta = 2
#' dlkj_arma(R, 2)
dlkj_arma <- function(R, eta, logd = FALSE) {
    .Call('_netcopula_dlkj_arma', PACKAGE = 'netcopula', R, eta, logd)
}

#' Generate random variate from a Lewandowski-Kurowicka-Joe distribution.
#'
#' Generation of a single draw from a Lewandowski-Kurowicka-Joe distribution
#' for a correlation matrix.
#'
#' @param K Length-one numeric vector that represents the size of the matrix.
#' @param eta Length-one numeric vector representing the parameter of the
#' distribution.
#'
#' @return A numeric (correlation) matrix.
#' @export
#'
#' @references
#' Lewandowski, D., Kurowicka, D., and Joe, H. (2009). Generating random
#' correlation matrices based on vines and extended onion method. Journal of
#' Multivariate Analysis, 100:1989-2001.
#' 
#' @details
#' This function is a port of the corresponding Stan (\url{http://mc-stan.
#' org}) function developed using the Eigen library (\url{http://eigen.
#' tuxfamily.org}).
#' 
#' @examples
#' set.seed(123)
#' K <- 5
#' rlkj_arma(K, .5) # eta = 0.5
#' rlkj_arma(K, 1) # eta = 1
#' rlkj_arma(K, 2) # eta = 2
rlkj_arma <- function(K, eta) {
    .Call('_netcopula_rlkj_arma', PACKAGE = 'netcopula', K, eta)
}

#' The truncated univariate normal distribution.
#'
#' Generation of draws from a truncated normal distribution with mean equal
#' to \code{mean} and standard deviation equal to \code{sd}.
#'
#' @param n Length-one numeric vector representing the number of draws.
#' @param a Numeric vector providing the lower bounds. These may be
#' \code{-Inf}.
#' @param b Numeric vector providing the upper bounds. These may be
#' \code{Inf}.
#' @param mean Numeric vector of means.
#' @param sd Numeric vector of standard deviations.
#'
#' @return A numeric vector.
#' @export
#'
#' @references
#' Geweke, J. (1991). Efficient simulation from the multivariate normal and
#' student-t distributions subject to linear constraints. In Computing Science
#' and Statistics: Proceedings of the 23rd Symposium on the Interface, ed. E.
#' Keramidas and S. Kaufman, pp. 571-8. Fairfax Station, VA: Interface
#' Foundation of North America.
#' 
#' @details
#' The values of \code{a}, \code{b}, \code{mean} and \code{sd} are recycled as
#' needed.
#'
#' This function is a Rcpp port of the corresponding 
#' \code{\link[truncnorm]{rtruncnorm}} function from the \code{truncnorm}
#' package.
#' 
#' @examples
#' n <- 20
#' a <- 0
#' b <- Inf
#' mean <- 0
#' sd <- 1
#' rng <- round(runif(1, 1, 10000))
#' set.seed(rng)
#' rtruncnorm_rcpp(n, a, b, mean, sd)
rtruncnorm_rcpp <- function(n, a, b, mean, sd) {
    .Call('_netcopula_rtruncnorm_rcpp', PACKAGE = 'netcopula', n, a, b, mean, sd)
}

#' The truncated univariate normal distribution.
#'
#' Generation of draws from a truncated normal distribution with mean equal
#' to \code{mean} and standard deviation equal to \code{sd}.
#'
#' @param n Length-one numeric vector representing the number of draws.
#' @param a Numeric vector providing the lower bounds. These may be
#' \code{-Inf}.
#' @param b Numeric vector providing the upper bounds. These may be
#' \code{Inf}.
#' @param mean Numeric vector of means.
#' @param sd Numeric vector of standard deviations.
#'
#' @return A numeric vector.
#' @export
#'
#' @references
#' Robert, C. (1995). Simulation of Truncated Normal Variables. Statistics
#' and Computing, 5, 121â€“125.
#' 
#' @details
#' The values of \code{a}, \code{b}, \code{mean} and \code{sd} are recycled as
#' needed.
#'
#' This function is a Rcpp port of the corresponding 
#' \code{\link[bayesm]{rtrun}} function from the \code{bayesm}
#' package.
#' 
#' @examples
#' n <- 20
#' a <- 0
#' b <- Inf
#' mean <- 0
#' sd <- 1
#' rng <- round(runif(1, 1, 10000))
#' set.seed(rng)
#' rtruncnorm2_rcpp(n, a, b, mean, sd)
rtruncnorm2_rcpp <- function(n, a, b, mean, sd) {
    .Call('_netcopula_rtruncnorm2_rcpp', PACKAGE = 'netcopula', n, a, b, mean, sd)
}

#' The truncated univariate normal distribution.
#'
#' Density of a truncated normal distribution with mean equal to \code{mean}
#' and standard deviation equal to \code{sd}.
#'
#' @param x Numeric vector containing the values at which to evaluate the
#' density.
#' @param a Numeric vector providing the lower bounds. These may be
#' \code{-Inf}.
#' @param b Numeric vector providing the upper bounds. These may be
#' \code{Inf}.
#' @param mean Numeric vector of means.
#' @param sd Numeric vector of standard deviations.
#'
#' @return A numeric vector.
#' @export
#'
#' @details
#' The values of \code{a}, \code{b}, \code{mean} and \code{sd} are recycled as
#' needed.
#'
#' This function is a Rcpp port of the corresponding 
#' \code{\link[truncnorm]{dtruncnorm}} function from the \code{truncnorm}
#' package.
#' 
#' @examples
#' a <- 0
#' b <- Inf
#' mean <- 0
#' sd <- 1
#' rng <- round(runif(1, 1, 10000))
#' set.seed(rng)
#' n <- 20
#' x <- rtruncnorm_rcpp(n, a, b, mean, sd)
#' dtruncnorm_rcpp(x, a, b, mean, sd)
dtruncnorm_rcpp <- function(x, a, b, mean, sd) {
    .Call('_netcopula_dtruncnorm_rcpp', PACKAGE = 'netcopula', x, a, b, mean, sd)
}

#' Log Cholesky prior distribution.
#'
#' Evaluation of the prior distribution based on the log Cholesky
#' factorization for a covariance matrix \eqn{\Sigma_M} .
#'
#' @param A Numeric matrix at which to evaluate the prior density.
#' @param sigma_r Length-one numeric vector providing the standard deviation
#' of the underlying normal distributions used to generate the Cholesky
#' factors.
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' M <- 5
#' sigma_r <- 10^-(1/3)
#' rng <- round(runif(1, 1, 10000))
#' set.seed(rng)
#' Sigma <- rlogchol_arma(M, sigma_r)
#' dlogchol_arma(Sigma, sigma_r)
dlogchol_arma <- function(A, sigma_r, logd = FALSE) {
    .Call('_netcopula_dlogchol_arma', PACKAGE = 'netcopula', A, sigma_r, logd)
}

#' Log Cholesky prior distribution.
#'
#' Generation of a single draw from the prior distribution of the
#' \eqn{\Sigma_M} matrix based on the log Cholesky factorization.
#'
#' @param M Length-one numeric vector representing the covariance matrix size.
#' @param sigma_r Length-one numeric vector providing the standard deviation
#' of the underlying normal distributions used to generate the Cholesky
#' factors.
#'
#' @return A numeric matrix.
#' @export
#'
#' @examples
#' M <- 5
#' sigma_r <- 10^-(1/3)
#' rng <- round(runif(1, 1, 10000))
#' set.seed(rng)
#' Sigma <- rlogchol_arma(M, sigma_r)
#' all(eigen(Sigma)$values > 0)
#' Sigma_sqrt <- solve(diag(diag(Sigma)))^0.5
#' Sigma_sqrt %*% Sigma %*% Sigma_sqrt
rlogchol_arma <- function(M, sigma_r) {
    .Call('_netcopula_rlogchol_arma', PACKAGE = 'netcopula', M, sigma_r)
}

#' Multivariate t density.
#'
#' Evaluate the multivariate t density.
#'
#' @param x Numeric matrix whose rows represent the points at which to
#' evaluate the density.
#' @param mean Numeric vector containing the univariate means.
#' @param sigma Numeric positive definite matrix representing the covariance
#' matrix of the distribution.
#' @param df Integer length-one vector providing the number of degrees of
#' freedom.
#' @param logd Boolean length-one vector; if TRUE the log density is returned.
#'
#' @return A numeric vector.
#' @export
#'
#' @references
#' \url{http://gallery.rcpp.org/articles/dmvnorm_arma/}
#' 
#' @examples
#' set.seed(123)
#' ### Covariance matrix and mean vector
#' sigma <- bayesm::rwishart(10, diag(8))$IW
#' mean <- rnorm(8)
#' ### Benchmarking
#' n <- 1e+4
#' df <- 20
#' X <- mvtnorm::rmvt(n, sigma, df, mean)
#' require(rbenchmark)
#' benchmark(mvtnorm::dmvt(X, mean, sigma, df, log = FALSE), 
#'           LearnBayes::dmt(X, mean, sigma, df, FALSE),
#'           dmvt_arma(X, mean, sigma, df, FALSE),
#'           order = "relative", replications = 100)[, 1:4]
dmvt_arma <- function(x, mean, sigma, df, logd = FALSE) {
    .Call('_netcopula_dmvt_arma', PACKAGE = 'netcopula', x, mean, sigma, df, logd)
}

#' Multivariate t variates generation.
#'
#' Generate of multivariate t variates.
#'
#' @param n Numeric length-one vector providing the number of draws to
#' generate.
#' @param mean Numeric vector containing the univariate means.
#' @param sigma Numeric positive definite matrix representing the covariance
#' matrix of the distribution.
#' @param df Integer length-one vector providing the number of degrees of
#' freedom.
#'
#' @return A numeric matrix.
#' @export
#'
#' @references
#' \url{http://gallery.rcpp.org/articles/simulate-multivariate-normal/}
#' 
#' @examples
#' set.seed(123)
#' ### Covariance matrix and mean vector
#' sigma <- matrix(c(1, 0.9, -0.3, 0.9, 1, -0.4, -0.3, -0.4, 1), ncol = 3)
#' mu <- c(10, 5, -3)
#' df <- 7
#' ### Benchmarking
#' n <- 1e+4
#' require(rbenchmark)
#' benchmark(mvtnorm::rmvt(n, sigma, df, mu),
#'           LearnBayes::rmt(n, mu, sigma, df),
#'           rmvt_arma(n, mu, sigma, df),
#'           columns = c("test", "replications", "relative", "elapsed"),
#'           order = "relative")
rmvt_arma <- function(n, mean, sigma, df) {
    .Call('_netcopula_rmvt_arma', PACKAGE = 'netcopula', n, mean, sigma, df)
}

#' Matrix variate normal density.
#'
#' Evaluate the matrix variate normal density.
#'
#' @param X Numeric matrix at which to evaluate the density.
#' @param M Numeric matrix containing the univariate means.
#' @param U Numeric positive definite matrix representing the covariance
#' matrix among the X rows.
#' @param V Numeric positive definite matrix representing the covariance
#' matrix among the X columns.
#' @param logd Boolean length-one vector; if TRUE the log density is returned.
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @references
#' \url{https://en.wikipedia.org/wiki/Matrix_normal_distribution}
#' 
#' @examples
#' set.seed(123)
#' n <- 10
#' p <- 3
#' x <- rnorm(n*p)
#' X <- matrix(x, nrow = n, ncol = p)
#' M <- matrix(0, nrow = n, ncol = p)
#' U <- diag(n)
#' V <- diag(p)
#' dmatvn_arma(X, M, U, V)
dmatvn_arma <- function(X, M, U, V, logd = FALSE) {
    .Call('_netcopula_dmatvn_arma', PACKAGE = 'netcopula', X, M, U, V, logd)
}

#' Matrix variate normal generation.
#'
#' Generate of a single matrix normal variate.
#'
#' @param M Numeric matrix containing the univariate means.
#' @param U Numeric positive definite matrix representing the covariance
#' matrix among the X rows.
#' @param V Numeric positive definite matrix representing the covariance
#' matrix among the X columns.
#'
#' @return A numeric matrix.
#' @export
#'
#' @references
#' \url{https://en.wikipedia.org/wiki/Matrix_normal_distribution}
#' 
#' @examples
#' set.seed(123)
#' n <- 10
#' p <- 3
#' M <- matrix(0, nrow = n, ncol = p)
#' U <- diag(n)
#' V <- diag(p)
#' rmatvn_arma(M, U, V)
#' set.seed(123)
#' rmvn_arma(n, rep(0, p), diag(p))
rmatvn_arma <- function(M, U, V) {
    .Call('_netcopula_rmatvn_arma', PACKAGE = 'netcopula', M, U, V)
}

#' Matrix variate t density.
#'
#' Evaluate the matrix variate t density.
#'
#' @param X Numeric matrix at which to evaluate the density.
#' @param M Numeric matrix containing the univariate means.
#' @param Omega Numeric positive definite matrix representing the covariance
#' matrix among the X rows.
#' @param Sigma Numeric positive definite matrix representing the covariance
#' matrix among the X columns.
#' @param df Integer length-one vector providing the number of degrees of
#' freedom.
#' @param logd Boolean length-one vector; if TRUE the log density is returned.
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @references
#' \url{https://en.wikipedia.org/wiki/Matrix_t_distribution}
#' 
#' @examples
#' set.seed(123)
#' n <- 10
#' p <- 3
#' x <- rnorm(n*p)
#' X <- matrix(x, nrow = n, ncol = p)
#' M <- matrix(0, nrow = n, ncol = p)
#' Sigma <- diag(n)
#' Omega <- diag(p)
#' df <- 5
#' dmatvt_arma(X, M, Sigma, Omega, df)
dmatvt_arma <- function(X, M, Sigma, Omega, df, logd = FALSE) {
    .Call('_netcopula_dmatvt_arma', PACKAGE = 'netcopula', X, M, Sigma, Omega, df, logd)
}

#' Matrix variate t generation.
#'
#' Generate of a single matrix t variate.
#'
#' @param M Numeric matrix containing the univariate means.
#' @param Omega Numeric positive definite matrix representing the covariance
#' matrix among the X rows.
#' @param Sigma Numeric positive definite matrix representing the covariance
#' matrix among the X columns.
#' @param df Integer length-one vector providing the number of degrees of
#' freedom.
#'
#' @return A numeric matrix.
#' @export
#'
#' @references
#' Kollo, T., van Rosen, D. (2005). Advanced Multivariate Statistics
#' with Matrices. Springer.
#' \url{https://en.wikipedia.org/wiki/Matrix_t_distribution}
#' 
#' @examples
#' set.seed(123)
#' n <- 10
#' p <- 3
#' x <- rnorm(n*p)
#' M <- matrix(0, nrow = n, ncol = p)
#' Sigma <- diag(n)
#' Omega <- diag(p)
#' df <- 5
#' rmatvt_arma(M, Sigma, Omega, df)
rmatvt_arma <- function(M, Sigma, Omega, df) {
    .Call('_netcopula_rmatvt_arma', PACKAGE = 'netcopula', M, Sigma, Omega, df)
}

#' Inverse gamma density.
#'
#' Evaluate the inverse gamma density.
#'
#' @param x Numeric vector whose representing the points at which to evaluate
#' the density.
#' @param alpha Inverse gamma shape parameter. Must be strictly positive.
#' @param beta Inverse gamma scale parameter. Must be strictly positive.
#' @param logd Boolean length-one vector; if TRUE the log density is returned.
#'
#' @return A numeric vector.
#' @export
#'
#' @examples
#' x <- seq(.01, 50, length.out = 1000)
#' alpha <- 1
#' beta <- 5
#' res <- dinvgamma_rcpp(x, alpha, beta)
#' plot(x, res, type = "l", main = "Inverse Gamma density")
dinvgamma_rcpp <- function(x, alpha, beta, logd = FALSE) {
    .Call('_netcopula_dinvgamma_rcpp', PACKAGE = 'netcopula', x, alpha, beta, logd)
}

#' Inverse gamma variates generation.
#'
#' Generate of inverse gamma variates.
#'
#' @param n Numeric length-one vector providing the number of draws to
#' generate.
#' @param alpha Inverse gamma shape parameter. Must be strictly positive.
#' @param beta Inverse gamma scale parameter. Must be strictly positive.
#'
#' @return A numeric vector.
#' @export
#'
#' @examples
#' set.seed(123)
#' n <- 1e4
#' alpha <- 3
#' beta <- 5
#' x <- sort(rinvgamma_rcpp(n, alpha, beta))
#' hist(x, breaks = 30, xlab = "x", freq = FALSE,
#'      main = "Inverse gamma variates")
#' lines(x, dinvgamma_rcpp(x, alpha, beta))
rinvgamma_rcpp <- function(n, alpha, beta) {
    .Call('_netcopula_rinvgamma_rcpp', PACKAGE = 'netcopula', n, alpha, beta)
}

#' Gaussian copula density evaluation.
#'
#' Evaluates a Gaussian copula density.
#'
#' @param u A numeric vector providing the point at which to evaluate the
#' copula density.
#' @param Gamma A numeric matrix providing the Gaussian copula correlation
#' matrix. These elements need to be provided row-wise (i.e., g_12, g_13,
#' \ldots, g_1M, g_23, g_24,\ldots, g_2M,\ldots,g_(M-1)(M-1)).
#' @param is_u A length-one logical vector indicating whether the \code{u}
#' argument provides the \eqn{u} or the \eqn{\Phi^{-1}(u)} values.
#' @param logd Boolean length-one vector; if TRUE the log density is returned.
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' u <- rep(0.1, 3)
#' Gamma <- c(.3, .5, .2)
#' gausscopdens(u, Gamma)
#' 
#' Gamma <- .3
#' len <- 100
#' u1 <- u2 <- seq(.01, .99, length.out = len)
#' dens <- matrix(NA, nrow = len, ncol = len)
#' for (i in 1:len) {
#'   for (j in 1:len) {
#'     dens[i, j] <- gausscopdens(c(u1[i], u2[j]), Gamma)
#'   }
#' }
#' persp(u1, u2, dens, theta = 120, phi = 25)
gausscopdens <- function(u, Gamma, is_u, logd = FALSE) {
    .Call('_netcopula_gausscopdens', PACKAGE = 'netcopula', u, Gamma, is_u, logd)
}

#' Subset Non-connected Regions
#'
#' Replicates the subset functionality of a matrix in R.
#' @param x       A \code{matrix} of dimensions M x N
#' @param row_ind A \code{unsigned int vec} that contains the row indices within \eqn{[0,M-1]}.
#' @param col_ind A \code{unsigned int vec} that contains the column indices within \eqn{[0,N-1]}.
#' @return A \code{vec} with each element listed according to index specification.
#' @author JJB
#' @examples
#' # Generate a Matrix
#' m = matrix(1:12, nrow = 4)
#'
#' # Select Non-connect regions
#' row_index = c(1, 2, 1)
#' col_index = c(2, 2, 3)
#'
#' # Subset in R
#' m[cbind(row_index, col_index)]
#'
#' # Subset with Armadillo
#' get_elements(m, row_index - 1, col_index - 1)
get_elements <- function(x, row_ind, col_ind) {
    .Call('_netcopula_get_elements', PACKAGE = 'netcopula', x, row_ind, col_ind)
}

#' Reverse Subset Column
#'
#' Subsets the column by going from high indices to low (the reverse of the supported practice)
#' @param x     A \code{matrix} of dimensions M x N
#' @param start A \code{unsigned int} that indicates the starting column.
#' @param end   A \code{unsigned int} that indicates the ending column.
#' @return A \code{matrix} with matrix rows displayed in reverse order
#' @details Consider a vector x=[[1,2],[3,4]].
#' By setting \code{start=1} and \code{end=0}, the function would output x=[[2,1],[4,1]].
#' Start and end must be valid C++ matrix locations. (e.g. matrix cols start at 0 and not 1)
#' @author JJB
#' @examples
#' x = matrix(c(1,2,3,4), nrow = 2,byrow = TRUE)
#' rev_col_subset(x, 1, 0)
rev_col_subset <- function(x, start, end) {
    .Call('_netcopula_rev_col_subset', PACKAGE = 'netcopula', x, start, end)
}

#' Reverse Subset Row
#'
#' Subsets the row by going from high indices to low (the reverse of the supported practice)
#' @param x A \code{matrix} of dimensions M x N
#' @param start A \code{unsigned int} that indicates the starting row.
#' @param end A \code{unsigned int} that indicates the ending row.
#' @return x A \code{matrix} with matrix rows displayed in reversed order
#' @details Consider a vector x=[[1,2],[3,4]], the function would output x=[[3,4],[1,2]].
#' Start and end must be valid C++ matrix locations. (e.g. matrix rows start at 0 and not 1)
#' @author JJB
#' @examples
#' x = matrix(c(1,2,3,4), nrow=2,byrow=TRUE)
#' rev_row_subset(x, 1, 0)
rev_row_subset <- function(x, start, end) {
    .Call('_netcopula_rev_row_subset', PACKAGE = 'netcopula', x, start, end)
}

#' Reverse Armadillo Vector
#'
#' Reverses the order of an Armadillo Vector
#' @param x A \code{column vector} of length N
#' @return A \code{column vector} with its contents reversed.
#' @details Consider a vector x=[1,2,3,4,5], the function would output x=[5,4,3,2,1].
#' @author JJB
#' @examples
#' x = 1:5
#' reverse_vec(x)
reverse_vec <- function(x) {
    .Call('_netcopula_reverse_vec', PACKAGE = 'netcopula', x)
}

#' Transform an Armadillo field<vec> to a matrix
#'
#' Unlists vectors in a field and places them into a matrix
#' @param x A \code{field<vec>}.
#' @return A \code{mat} containing the field elements within a column.
#' @author JJB
field_to_matrix <- function(x) {
    .Call('_netcopula_field_to_matrix', PACKAGE = 'netcopula', x)
}

#' Accumulation of Armadillo field<vec>
#'
#' Sums vectors in a field into a single variable.
#' @param x A \code{field<vec>}.
#' @return An \code{mat} containing the field elements within a column.
#' @author JJB
sum_field_vec <- function(x) {
    .Call('_netcopula_sum_field_vec', PACKAGE = 'netcopula', x)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param nc_data pippo
#' @param x pippo
#' @param mu pippo
#' @param delta pippo
#' @param Gamma pippo
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' # nothing for now!
mudelta_logpost <- function(mudelta, delta_arma, y, n, x, baseline, trt, study, narms, d, Sigma_M, Gamma, m, mu_sigma, eps, eps_ab) {
    .Call('_netcopula_mudelta_logpost', PACKAGE = 'netcopula', mudelta, delta_arma, y, n, x, baseline, trt, study, narms, d, Sigma_M, Gamma, m, mu_sigma, eps, eps_ab)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param data pippo
#' @param init pippo
#' @param totiter pippo
#' @param prior pippo
#' @param prop pippo
#' @param verbose pippo
#'
#' @return A list containing the output of the MCMC simulation.
#' @export
#'
#' @examples
#' # nothing for now!
nc_mcmc_mh_new <- function(data, init, totiter, prior, prop, tuning, adapt, verbose) {
    .Call('_netcopula_nc_mcmc_mh_new', PACKAGE = 'netcopula', data, init, totiter, prior, prop, tuning, adapt, verbose)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param nc_data pippo
#' @param x pippo
#' @param mu pippo
#' @param delta pippo
#' @param Gamma pippo
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' # nothing for now!
mudelta_logpost2 <- function(mudelta, delta_arma, y, n, x, baseline, trt, study, narms, d, Sigma_M, Gamma, i, m, mu_sigma, eps, eps_ab) {
    .Call('_netcopula_mudelta_logpost2', PACKAGE = 'netcopula', mudelta, delta_arma, y, n, x, baseline, trt, study, narms, d, Sigma_M, Gamma, i, m, mu_sigma, eps, eps_ab)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param data pippo
#' @param init pippo
#' @param totiter pippo
#' @param prior pippo
#' @param prop pippo
#' @param verbose pippo
#'
#' @return A list containing the output of the MCMC simulation.
#' @export
#'
#' @examples
#' # nothing for now!
nc_mcmc_mh_new2 <- function(data, init, totiter, prior, prop, tuning, adapt, verbose) {
    .Call('_netcopula_nc_mcmc_mh_new2', PACKAGE = 'netcopula', data, init, totiter, prior, prop, tuning, adapt, verbose)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param y pippo
#' @param n pippo
#' @param x pippo
#' @param trt pippo
#' @param mu pippo
#' @param delta pippo
#' @param Gamma pippo
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' # nothing for now!
nc_loglik <- function(y, n, x, trt, mu, delta, Gamma) {
    .Call('_netcopula_nc_loglik', PACKAGE = 'netcopula', y, n, x, trt, mu, delta, Gamma)
}

#' @export
indic_a_b <- function(y_ikm, n_ikm, x_ikm, mu_ikm, delta_ikm) {
    .Call('_netcopula_indic_a_b', PACKAGE = 'netcopula', y_ikm, n_ikm, x_ikm, mu_ikm, delta_ikm)
}

#' @export
nc_logprior <- function(mu, mu_sigma, d, d_sigma, Sigma_M, sigma_r, ref_trt) {
    .Call('_netcopula_nc_logprior', PACKAGE = 'netcopula', mu, mu_sigma, d, d_sigma, Sigma_M, sigma_r, ref_trt)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param data pippo
#' @param init pippo
#' @param totiter pippo
#' @param prior pippo
#' @param prop pippo
#' @param verbose pippo
#'
#' @return A list containing the output of the MCMC simulation.
#' @export
#'
#' @examples
#' # nothing for now!
x_imputed <- function(x, Gamma, trt) {
    .Call('_netcopula_x_imputed', PACKAGE = 'netcopula', x, Gamma, trt)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param data pippo
#' @param init pippo
#' @param totiter pippo
#' @param prior pippo
#' @param prop pippo
#' @param verbose pippo
#'
#' @return A list containing the output of the MCMC simulation.
#' @export
#'
#' @examples
#' # nothing for now!
n_imputed <- function(n_data) {
    .Call('_netcopula_n_imputed', PACKAGE = 'netcopula', n_data)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param data pippo
#' @param init pippo
#' @param totiter pippo
#' @param prior pippo
#' @param prop pippo
#' @param verbose pippo
#'
#' @return A list containing the output of the MCMC simulation.
#' @export
#'
#' @examples
#' # nothing for now!
y_imputed <- function(y, x_imp, narms, mu, delta, n_imp) {
    .Call('_netcopula_y_imputed', PACKAGE = 'netcopula', y, x_imp, narms, mu, delta, n_imp)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param nc_data pippo
#' @param x pippo
#' @param mu pippo
#' @param delta pippo
#' @param Gamma pippo
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' # nothing for now!
Gamma_logpost <- function(Gamma, x, eta) {
    .Call('_netcopula_Gamma_logpost', PACKAGE = 'netcopula', Gamma, x, eta)
}

#' @export
logpost <- function(mu, delta, y, n, w, gamma, eps, eps_ab) {
    .Call('_netcopula_logpost', PACKAGE = 'netcopula', mu, delta, y, n, w, gamma, eps, eps_ab)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param nc_data pippo
#' @param x pippo
#' @param mu pippo
#' @param delta pippo
#' @param Gamma pippo
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' # nothing for now!
mu_logpost <- function(mu, delta, y, n, w, gamma, mu_sigma, eps, eps_ab) {
    .Call('_netcopula_mu_logpost', PACKAGE = 'netcopula', mu, delta, y, n, w, gamma, mu_sigma, eps, eps_ab)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param nc_data pippo
#' @param x pippo
#' @param mu pippo
#' @param delta pippo
#' @param Gamma pippo
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' # nothing for now!
delta_logpost <- function(delta, mu, tau, eta, y, n, w, gamma, eps, eps_ab) {
    .Call('_netcopula_delta_logpost', PACKAGE = 'netcopula', delta, mu, tau, eta, y, n, w, gamma, eps, eps_ab)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param nc_data pippo
#' @param x pippo
#' @param mu pippo
#' @param delta pippo
#' @param Gamma pippo
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' # nothing for now!
delta_logprior <- function(delta, d, Sigma_M, trt_arms, baseline, narms) {
    .Call('_netcopula_delta_logprior', PACKAGE = 'netcopula', delta, d, Sigma_M, trt_arms, baseline, narms)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param nc_data pippo
#' @param x pippo
#' @param mu pippo
#' @param delta pippo
#' @param Gamma pippo
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' # nothing for now!
d_logprior <- function(d, d_sigma, ref_trt) {
    .Call('_netcopula_d_logprior', PACKAGE = 'netcopula', d, d_sigma, ref_trt)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param nc_data pippo
#' @param x pippo
#' @param mu pippo
#' @param delta pippo
#' @param Gamma pippo
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' # nothing for now!
d_logpost_multi <- function(d, delta, Sigma_M, trt_arms, baseline, narms, d_sigma, ref_trt) {
    .Call('_netcopula_d_logpost_multi', PACKAGE = 'netcopula', d, delta, Sigma_M, trt_arms, baseline, narms, d_sigma, ref_trt)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param nc_data pippo
#' @param x pippo
#' @param mu pippo
#' @param delta pippo
#' @param Gamma pippo
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' # nothing for now!
d_logpost <- function(d, delta, Sigma_M, trt, baseline, narms_study, d_sigma, ref_trt) {
    .Call('_netcopula_d_logpost', PACKAGE = 'netcopula', d, delta, Sigma_M, trt, baseline, narms_study, d_sigma, ref_trt)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param nc_data pippo
#' @param x pippo
#' @param mu pippo
#' @param delta pippo
#' @param Gamma pippo
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' # nothing for now!
Sigma_M_logpost <- function(d, delta, Sigma_M, trt, baseline, narms_study, sigma_r) {
    .Call('_netcopula_Sigma_M_logpost', PACKAGE = 'netcopula', d, delta, Sigma_M, trt, baseline, narms_study, sigma_r)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param data pippo
#' @param init pippo
#' @param totiter pippo
#' @param prior pippo
#' @param prop pippo
#' @param verbose pippo
#'
#' @return A list containing the output of the MCMC simulation.
#' @export
#'
#' @examples
#' # nothing for now!
nc_mcmc_opt <- function(data, init, totiter, prior, prop, tuning, adapt, verbose) {
    .Call('_netcopula_nc_mcmc_opt', PACKAGE = 'netcopula', data, init, totiter, prior, prop, tuning, adapt, verbose)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param y pippo
#' @param n pippo
#' @param x pippo
#' @param trt pippo
#' @param mu pippo
#' @param delta pippo
#' @param Gamma pippo
#'
#' @return A length-one numeric vector.
#' @export
#'
#' @examples
#' # nothing for now!
rwmh_adapt <- function(theta, mu, rho, cov, ar, alpha, beta, gamma, tar, k, iter_cols, what, diagonal) {
    .Call('_netcopula_rwmh_adapt', PACKAGE = 'netcopula', theta, mu, rho, cov, ar, alpha, beta, gamma, tar, k, iter_cols, what, diagonal)
}

#' Log-likelihood of copula based model for a multivariate NMA.
#'
#' Evaluation of the log-likelihood.
#'
#' @param data pippo
#' @param init pippo
#' @param totiter pippo
#' @param prior pippo
#' @param prop pippo
#' @param verbose pippo
#'
#' @return A list containing the output of the MCMC simulation.
#' @export
#'
#' @examples
#' # nothing for now!
nc_mcmc_mh <- function(data, init, totiter, prior, prop, tuning, adapt, verbose) {
    .Call('_netcopula_nc_mcmc_mh', PACKAGE = 'netcopula', data, init, totiter, prior, prop, tuning, adapt, verbose)
}

#' @export
optim_rcpp <- function(par, fn, args, options, hessian = TRUE) {
    .Call('_netcopula_optim_rcpp', PACKAGE = 'netcopula', par, fn, args, options, hessian)
}

#' @export
optimhess_rcpp <- function(par, fn, args, options) {
    .Call('_netcopula_optimhess_rcpp', PACKAGE = 'netcopula', par, fn, args, options)
}

#' @export
laplace_rcpp <- function(logpost, guess, args, options) {
    .Call('_netcopula_laplace_rcpp', PACKAGE = 'netcopula', logpost, guess, args, options)
}

#' @export
optim_rcpp_example <- function() {
    .Call('_netcopula_optim_rcpp_example', PACKAGE = 'netcopula')
}

#' @export
optimize_rcpp <- function(fn, xmin, xmax, tol, args) {
    .Call('_netcopula_optimize_rcpp', PACKAGE = 'netcopula', fn, xmin, xmax, tol, args)
}

#' @export
laplace_u_rcpp <- function(fn, xmin, xmax, tol, args, options) {
    .Call('_netcopula_laplace_u_rcpp', PACKAGE = 'netcopula', fn, xmin, xmax, tol, args, options)
}

#' @export
mat_block_diag <- function(A, n) {
    .Call('_netcopula_mat_block_diag', PACKAGE = 'netcopula', A, n)
}

#' @export
Sigma_block <- function(Sigma_M, n) {
    .Call('_netcopula_Sigma_block', PACKAGE = 'netcopula', Sigma_M, n)
}

#' @export
df_nm <- function(x, cols) {
    .Call('_netcopula_df_nm', PACKAGE = 'netcopula', x, cols)
}

#' @export
nm_stack <- function(x) {
    .Call('_netcopula_nm_stack', PACKAGE = 'netcopula', x)
}

#' @export
nv_unstack <- function(x, nc) {
    .Call('_netcopula_nv_unstack', PACKAGE = 'netcopula', x, nc)
}

#' @export
nv_omit <- function(x) {
    .Call('_netcopula_nv_omit', PACKAGE = 'netcopula', x)
}

#' @export
nv_na_index <- function(x, dim, type) {
    .Call('_netcopula_nv_na_index', PACKAGE = 'netcopula', x, dim, type)
}

#' @export
nv_miss_replace <- function(x, miss, miss_i) {
    .Call('_netcopula_nv_miss_replace', PACKAGE = 'netcopula', x, miss, miss_i)
}

#' @export
split_iv <- function(x, f) {
    .Call('_netcopula_split_iv', PACKAGE = 'netcopula', x, f)
}

#' @export
split_nm <- function(x, f) {
    .Call('_netcopula_split_nm', PACKAGE = 'netcopula', x, f)
}

#' @export
logit_rcpp <- function(p) {
    .Call('_netcopula_logit_rcpp', PACKAGE = 'netcopula', p)
}

#' @export
expit_rcpp <- function(x) {
    .Call('_netcopula_expit_rcpp', PACKAGE = 'netcopula', x)
}

#' @export
nm_omit <- function(x, rownum) {
    .Call('_netcopula_nm_omit', PACKAGE = 'netcopula', x, rownum)
}

#' @export
param_long <- function(prm_wide, narms, rowindex) {
    .Call('_netcopula_param_long', PACKAGE = 'netcopula', prm_wide, narms, rowindex)
}

#' @export
param_wide <- function(prm_long, narms, trt, baseline) {
    .Call('_netcopula_param_wide', PACKAGE = 'netcopula', prm_long, narms, trt, baseline)
}

#' @export
list_mat <- function(X) {
    .Call('_netcopula_list_mat', PACKAGE = 'netcopula', X)
}

#' @export
diag_tri <- function(A) {
    .Call('_netcopula_diag_tri', PACKAGE = 'netcopula', A)
}

#' @export
cube_to_mat <- function(X, is_d, ref) {
    .Call('_netcopula_cube_to_mat', PACKAGE = 'netcopula', X, is_d, ref)
}

#' @export
mat_to_vec <- function(X, is_d, ref) {
    .Call('_netcopula_mat_to_vec', PACKAGE = 'netcopula', X, is_d, ref)
}

#' @export
vec_to_mat <- function(x, nc, is_d, ref) {
    .Call('_netcopula_vec_to_mat', PACKAGE = 'netcopula', x, nc, is_d, ref)
}

#' @export
Sigma_M_to_beta <- function(A) {
    .Call('_netcopula_Sigma_M_to_beta', PACKAGE = 'netcopula', A)
}

#' @export
beta_to_Sigma_M <- function(beta, M) {
    .Call('_netcopula_beta_to_Sigma_M', PACKAGE = 'netcopula', beta, M)
}

#' @export
is_symmetric <- function(A) {
    .Call('_netcopula_is_symmetric', PACKAGE = 'netcopula', A)
}

#' @export
is_correlation <- function(A) {
    .Call('_netcopula_is_correlation', PACKAGE = 'netcopula', A)
}

#' @export
is_positive_definite <- function(A, line) {
    .Call('_netcopula_is_positive_definite', PACKAGE = 'netcopula', A, line)
}

#' @export
make_positive_definite <- function(A) {
    .Call('_netcopula_make_positive_definite', PACKAGE = 'netcopula', A)
}

#' @export
is_singular <- function(A) {
    .Call('_netcopula_is_singular', PACKAGE = 'netcopula', A)
}

#' @export
ols_coef <- function(xmin, xmax, args, delta_par) {
    .Call('_netcopula_ols_coef', PACKAGE = 'netcopula', xmin, xmax, args, delta_par)
}

#' @export
ols_pred <- function(coef, x) {
    .Call('_netcopula_ols_pred', PACKAGE = 'netcopula', coef, x)
}

#' @export
cov2cor_rcpp <- function(V) {
    .Call('_netcopula_cov2cor_rcpp', PACKAGE = 'netcopula', V)
}

